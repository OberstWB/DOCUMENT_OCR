#include "stdafx.h"
#include "NormalSegRec.h"
#include "OCREngine.h"
#include"OCR.h"

//#define NPNTR_ID
#ifdef _DEBUG
#ifdef NPNTR_ID
#pragma comment (lib,"IDCard_NPNTR.lib")
#else
#pragma comment (lib, "OCREngineD.lib")
#endif
#else
#ifdef NPNTR_ID
#pragma comment (lib,"IDCard_NPNTR.lib")
#else
#pragma comment (lib, "OCREngine.lib")
#endif
#endif

using namespace SegAndRec_table_ocr;

namespace SegAndRec_table_ocr
{

#define  PI      (3.1415926)
#define Degree2Radian(X)    ((X) * (PI/180))
#define Radian2Degree(X)    ((X) * (180/PI))
#define sind(X)      ( sin( (Degree2Radian((X)))) )
#define cosd(X)      ( cos( (Degree2Radian((X)))) )
#define D2  (1.4142)
#define GEO_PIT (1)
#define GEO_MAX      (0)
#define GEO_MIN      (1)
#define GEO_ASCEND   (2)
#define GEO_DESCEND  (3)
#define GEO_EVEN     (4)
#define GEO_OTHER    (5)

#define GEO_MAIN_HV    (0)
#define GEO_MAIN_DIAG  (1)

#define GEO_PEAK       (0)
#define GEO_PIT        (1)
#define GEO_SADDLE     (2)
#define GEO_RIDGE      (3)
#define GEO_RAVINE     (4)
#define GEO_HILLSIDE   (5)

#define ASWR_ERROR     (-1)
#define m_iBwMethod 0
#define BINARY_DENBW (4)

struct npntr_ID_Engine
{
	OCR pEngine;
};
bool initialSegmentationParam(stLineSegmentationParam &m_tLineSegmentationParam)
{
	m_tLineSegmentationParam.iPixelTh   = 10;
	m_tLineSegmentationParam.dbRatioTh  = 1.23;////王博20171018修改为1.15，后来又改回1.23（配合代发工资单）
	m_tLineSegmentationParam.lMaxDist   = 80000;
	m_tLineSegmentationParam.lDistRatio = 0.8;
	m_tLineSegmentationParam.lMaxHigh   = 50;
	m_tLineSegmentationParam.lMaxWidth  = 100;
	return true;
}

bool CmpRectByXPosAscend( const SHAPE_RECT &tRect1, const SHAPE_RECT &tRect2 )
{
	//	DEBUG("");
	return (tRect1.tTopLeft.x < tRect2.tTopLeft.x);
}

bool CmpOcrRectByXPosAscend( const stOcrRect &tOcrRect1, const stOcrRect &tOcrRect2 ) //升序
{
	return CmpRectByXPosAscend(tOcrRect1.tRect,tOcrRect2.tRect);
}

void Ascii2WideString( const string& szStr, wstring& wszStr )
{
	/*DEBUG("");*/
	int nLength = MultiByteToWideChar( CP_ACP, 0, szStr.c_str(), -1, NULL, NULL );
	wszStr.resize(nLength);
	LPWSTR lpwszStr = new wchar_t[nLength];
	MultiByteToWideChar( CP_ACP, 0, szStr.c_str(), -1, lpwszStr, nLength );
	wszStr = lpwszStr;

	if (lpwszStr != NULL)
	{
		delete [] lpwszStr;
		lpwszStr = NULL;
	}

	//delete [] lpwszStr;

	/*DEBUG("D");*/
	return;
}

void UnicodeToAnsi( const wstring strUnicode,string &strAnsi )
{
	/*DEBUG("");*/
	if ( strUnicode.length() == 0 )
	{
		/*DEBUG("");*/
		strAnsi = "";
		return;
	}

	int nLen = WideCharToMultiByte( CP_ACP, 0, strUnicode.c_str(), -1, NULL, 0, NULL, NULL );
	if (nLen == 0)
	{
		strAnsi = "";
		return;
	}

	char* pResult = new char[nLen];
	WideCharToMultiByte( CP_ACP, 0, strUnicode.c_str(), -1, pResult, nLen, NULL, NULL );

	strAnsi = pResult;

	if (pResult != NULL)
	{
		delete [] pResult;
		pResult = NULL;
	}
	//delete [] pResult;

	/*DEBUG("D");*/
	return;
}

void DrawBoxes( Mat &tImage,const RECTS &tRects,int iGray)
{
	/*DEBUG("");*/
	int i;
	SHAPE_RECT tRect;
	for( i=0; i<tRects.size(); i++ )
	{
		tRect = tRects[i];
		int x1,y1,x2,y2,x3,y3,x4,y4;

		x1 = int(tRect.tTopLeft.x);     y1 = int(tRect.tTopLeft.y);
		x2 = int(tRect.tButtomRight.x); y2 = int(tRect.tTopLeft.y);
		x3 = int(tRect.tButtomRight.x); y3 = int(tRect.tButtomRight.y);
		x4 = int(tRect.tTopLeft.x);     y4 = int(tRect.tButtomRight.y);

		line(tImage, Point(x1,y1), Point(x2,y2), Scalar(iGray), 1);
		line(tImage, Point(x2,y2), Point(x3,y3), Scalar(iGray), 1);
		line(tImage, Point(x3,y3), Point(x4,y4), Scalar(iGray), 1);
		line(tImage, Point(x4,y4), Point(x1,y1), Scalar(iGray),1);

	}
	/*DEBUG("D");*/
}

bool IsNumChar1(const tstring &strChar)
{
	/*DEBUG("");*/
	tstring strFirstChar;

	if ( strChar.length() == 0 )
	{
		/*DEBUG("F");*/
		return false;
	}

	strFirstChar = strChar.substr(0,1);

	bool bFund = false; 
	int idx;
	tstring strNum = _T("0123456789X");

	idx = strNum.find_first_of(strFirstChar); 
	if ( idx != tstring::npos )
	{
		bFund = true;
	}

	/*DEBUG("D");*/
	return bFund;

}

bool IsNumChar(const tstring &strChar)
{
	/*DEBUG("");*/
	tstring strFirstChar;

	if ( strChar.length() == 0 )
	{
		/*DEBUG("F");*/
		return false;
	}

	strFirstChar = strChar.substr(0,1);

	bool bFund = false; 
	int idx;
	tstring strNum = _T("0123456789");

	idx = strNum.find_first_of(strFirstChar); 
	if ( idx != tstring::npos )
	{
		bFund = true;
	}
	/*DEBUG("D");*/
	return bFund;

}

bool IsEnglishChar(const tstring &strChar)
{
	/*DEBUG("");*/
	tstring strFirstChar;

	if ( strChar.length() == 0 )
	{
		/*DEBUG("F");*/
		return false;
	}

	strFirstChar = strChar.substr(0,1);

	bool bFund = false; 
	int idx;
	tstring strNum = _T("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");

	idx = strNum.find_first_of(strFirstChar); 
	if ( idx != tstring::npos )
	{
		bFund = true;
	}
	/*DEBUG("D");*/
	return bFund;

}

bool IsPunctuationChar(const tstring &strChar)
{
	/*DEBUG("");*/
	tstring strFirstChar;

	if ( strChar.length() == 0 )
	{
		/*DEBUG("D");*/
		return false;
	}

	strFirstChar = strChar.substr(0,1);

	bool bFund = false; 
	int idx;
	
	tstring strNum = _T("{}[]:(),.';\"?!（）；。‘’“”：？！《》】【--");

	idx = strNum.find_first_of(strFirstChar); 
	if ( idx != tstring::npos )
	{
		bFund = true;
	}
	/*DEBUG("D");*/
	return bFund;
}

bool IsChineseChar(const tstring &strChar)
{
	/*DEBUG("");*/
	if ( strChar == _T("") )
	{
		/*DEBUG("F");*/
		return false;
	}

	if ( IsNumChar(strChar) )
	{
		/*DEBUG("F");*/
		return false;
	}
	if ( IsEnglishChar(strChar) )
	{
		/*DEBUG("F");*/
		return false;
	}
	if ( IsPunctuationChar(strChar) )
	{
		/*DEBUG("F");*/
		return false;
	}

	/*DEBUG("D");*/
	return true;
}

void ComputeRect(const SHAPE_RECT &tRect,double &dbHeight,double &dbWidth,double &dbRatio,double &dbCenterX,double &dbCenterY)
{
	/*DEBUG("");*/
	dbWidth  = tRect.tButtomRight.x - tRect.tTopLeft.x;
	dbHeight = tRect.tButtomRight.y - tRect.tTopLeft.y;

	dbRatio = 0;
	if ( dbHeight > 0.01 )
	{
		dbRatio  = dbWidth/dbHeight;
	}


	dbCenterX = tRect.tTopLeft.x + dbWidth/2;
	dbCenterY = tRect.tTopLeft.y + dbHeight/2;
	/*DEBUG("D");*/
}

void ConnComponent(Mat &tBw,int iPixelTh,RECTS &tRects,vector<double> &tConnAreas,bool bFill,uchar cFillVal,Mat &tFilledImg)
{
	/*DEBUG("");*/
	vector<vector<Point>> contours;
	vector<Vec4i> hierarchy;

	// 	CERT_IMAGE tBwImageTmp = Mat::zeros(tBw.rows+2,tBw.cols+2,CV_8UC1);
	// 	Mat tBwImageTmp1 = tBwImageTmp(Range(1,tBw.rows+1),Range(1,tBw.cols+1));
	// 	tBw.copyTo(tBwImageTmp(Range(1,tBw.rows+1),Range(1,tBw.cols+1)));
	Mat tBwImageTmp;
	tBw.copyTo(tBwImageTmp);


	findContours(tBwImageTmp, contours , hierarchy , CV_RETR_TREE , CV_CHAIN_APPROX_NONE,Point(0, 0)); //查找连通区域


	double dbArea = 0;
	SHAPE_RECT tRect;

	int iNum = 0;

	if (!contours.empty())
	{
		for (int idx=0;idx>=0;idx=hierarchy[idx][0])
			//for (int idx=0;idx<contours.size();idx++)
		{
			Rect cBoundingBox = boundingRect(Mat(contours[idx]));

			Mat tRectImg = tBw(Range(cBoundingBox.y,cBoundingBox.y + cBoundingBox.height), 
				Range(cBoundingBox.x,cBoundingBox.x + cBoundingBox.width));

			int nIndex = sum(tRectImg)[0] / 255;

			//ShowMat(tRectImg);
			
			dbArea = contourArea(contours[idx]);

			if ( dbArea < iPixelTh )
			{				
				if ( bFill && (nIndex < 6))
				{
					Point pt;
					for ( int i=0; i<contours[idx].size(); i++ )
					{
						pt = contours[idx][i];
						tFilledImg.at<uchar>(pt.y,pt.x) = cFillVal;
					}

					continue;

				}//if ( bFill )

				
			}

			//ShowMat(tRectImg,"conn",true);

			tRect.tTopLeft.x = cBoundingBox.x;
			tRect.tTopLeft.y = cBoundingBox.y;
			tRect.tButtomRight.x = tRect.tTopLeft.x + cBoundingBox.width-1;
			tRect.tButtomRight.y = tRect.tTopLeft.y + cBoundingBox.height-1;
			tRects.push_back(tRect);
			tConnAreas.push_back(dbArea);

			//iNum++;
			//sprintf(ch,"%d",iNum);
			//string str = "Connection";
			//str = str + ch;
			//ShowMat(tRectImg,str);

		}//for (int idx=0;idx>=0;idx=hierarchy[idx][0])
	}//if (!contours.empty())

	/*DEBUG("D");*/
	return;
}

bool NoSegmentSpacialChar(const tstring &str)
{
	/*DEBUG("");*/
	if ( str == _T("一") )
	{
		/*DEBUG("D");*/
		return true;
	}

	if ( str == _T("二") )
	{
		/*DEBUG("D");*/
		return true;
	}

	if ( str == _T("三") )
	{
		/*DEBUG("D");*/
		return true;
	}

	if ( str == _T("工") )
	{
		/*DEBUG("D");*/
		return true;
	}
	if ( str == _T("-") )
	{
		/*DEBUG("D");*/
		return true;
	}
	/*DEBUG("F");*/
	return false;
}

void GaussSmoothArray(vector<int> &tArray,int iWin,vector<double> &tOutArray)
{
	/*DEBUG("");*/
	int W = iWin/2;

	//Mat tKernal = getGaussianKernel(2*W + 1,0);
	//vector<double> dbKernalArray(2*W + 1);

	// 	Mat src(1,tArray.size(),CV_64F, Scalar(0));
	// 	for ( int i=0; i<tArray.size(); i++)
	// 	{
	// 		src.at<double>(i) = tArray[i];
	// 	}
	// 
	// 	Mat dst;
	// 	GaussianBlur(src,dst, Size(1,iWin),5);

	Mat kernel = getGaussianKernel(iWin,1);

	tOutArray.resize(tArray.size(),0);

	for (int i=W; i<tArray.size()-W; i++)
	{
		for (int j=-W; j<=W; j++)
		{
			tOutArray[i] += tArray[i+j]*kernel.at<double>(j+W);
		}
		//tOutArray[i] /= 2*W + 1;
	}
	/*DEBUG("");*/
}

void GaussSmoothArray(vector<double> &tArray,int iWin,vector<double> &tOutArray)
{
	/*DEBUG("");*/
	int W = iWin/2;

	Mat kernel = getGaussianKernel(iWin,1);

	tOutArray.resize(tArray.size(),0);

	for (int i=W; i<tArray.size()-W; i++)
	{
		for (int j=-W; j<=W; j++)
		{
			tOutArray[i] += tArray[i+j]*kernel.at<double>(j+W);
		}
		//tOutArray[i] /= 2*W + 1;
	}
	/*DEBUG("");*/
}

void GaussSmoothArray(vector<int> &tArray,int iWin)
{
	/*DEBUG("");*/
	int W = iWin/2;

	//Mat tKernal = getGaussianKernel(2*W + 1,0);
	//vector<double> dbKernalArray(2*W + 1);

	Mat src(1,tArray.size(),CV_64F, Scalar(0));
	for ( int i=0; i<tArray.size(); i++)
	{
		src.at<double>(i) = tArray[i];
	}

	Mat dst;
	GaussianBlur(src,dst, Size(1,iWin),5);

	for ( int i=0; i<tArray.size(); i++)
	{
		tArray[i] = int(dst.at<double>(i));
	}
	/*DEBUG("");*/
}

void Profile(const Mat &tBwImage,vector<double> &tProfile)
{
	int iWidth,iHeight;

	iWidth = tBwImage.cols;
	iHeight = tBwImage.rows;

	int i,j;

	vector<int> tTopProfile(iWidth),tBottomProfile(iWidth);

	for ( i=0; i<iWidth; i++ )
	{
		tTopProfile[i]    = 0;
		tBottomProfile[i] = 0;

		for ( j=0; j<iHeight; j++ )
		{
			if ( tBwImage.at<uchar>(j,i) == 0 )
			{
				tTopProfile[i]++;
			}
			else
			{
				break;
			}

		}//for ( j=0; j<iHeight; j++ )

		for ( j=iHeight-1; j>0; j-- )
		{
			if ( tBwImage.at<uchar>(j,i) == 0 )
			{
				tBottomProfile[i]++;
			}
			else
			{
				break;
			}

		}//for ( j=iHeight-1; j>0; j-- )

		//tDiff[i] = tTopProfile[i]+tBottomProfile[i];

	}//for ( i=0; i<iWidth; i++ )

	vector<double> tTopProfiles(iWidth),tBottomProfiles(iWidth);

	GaussSmoothArray(tTopProfile,5,tTopProfiles);
	GaussSmoothArray(tBottomProfile,5,tBottomProfiles);

	tProfile.resize(iWidth);

	for ( int i=0; i<iWidth; i++ )
	{
		tProfile[i] = tTopProfiles[i]+tBottomProfiles[i];
	}

	return;

}
void ProfilePeak(const vector<double> &tArray,vector<double> &tOutArray)
{
	int iWidth = tArray.size();
	tOutArray.resize(iWidth,0);

	for( int i=2; i<iWidth-2; i++ )
	{
		if( ((tArray[i]>tArray[i-1]) && (tArray[i]>tArray[i+1])) || 
			((tArray[i]>tArray[i-2]) && (tArray[i]>tArray[i+2])) )
		{
			tOutArray[i] = tArray[i];
		}

	}//for( int i=1; i<iWidth-1; i++ )

	return;
}

bool SegmentByProfilePeak(Mat &tBw,RECTS &tRects)
{
	vector<double> tProfile,tProfilePeak,tProfiles;
	int i;

	/*    ShowMat(tBw,"SegmentByProfilePeak",true);*/

	Profile(tBw,tProfile);
	/*	Supression(tProfile,10,tProfiles);*/

	ProfilePeak(tProfile,tProfilePeak);

	// 	for ( i=4; i<tProfiles.size()-4; i++ )
	// 	{
	// 		if ( tProfiles[i] > 0  )
	// 		{
	// 			if( (tProfile[i] > tProfile[i-4]) && (tProfile[i] > tProfile[i+4]) )
	// 			{
	// 				tProfilePeak[i] = tProfilePeak[i] + tProfiles[i];
	// 			}
	// 		}
	// 		
	// 	}

	int lastp = 0;

	int offset = 5;

	int iWidth = tProfilePeak.size();
	int iHeight = tBw.rows;

	double dbThred = 0;

	SHAPE_RECT tRect;

	for( i=0; i<iWidth; i++ )
	{
		if( i >= (iWidth-offset))
		{
			tRect.tTopLeft.x = lastp;
			tRect.tTopLeft.y = 0;
			tRect.tButtomRight.x = iWidth-1;
			tRect.tButtomRight.y = iHeight-1;
			tRects.push_back(tRect);
			break;

		}//if( i >= (iWidth-offset))

		if( tProfilePeak[i] > dbThred )
		{

			if( (i-lastp) >offset )
			{
				if ((tProfile[i]>tProfile[i-1]) || (tProfile[i]>tProfile[i+1]))
				{
					tRect.tTopLeft.x = lastp;
					tRect.tTopLeft.y = 0;
					tRect.tButtomRight.x = i;
					tRect.tButtomRight.y = iHeight-1;
					tRects.push_back(tRect);

					lastp = i+1;

				}


			}//if( (i-lastp) >offset )

		}//if( tProfiles[i] > iThred )

	}//for( i=0; i<iWidth; i++ )

	return true;
}

bool SegmentByProfile(Mat &tBw,RECTS &tRects)
{
	return SegmentByProfilePeak(tBw,tRects);
}

void MergeOverlap(long handle, int iType,MyOcrEngine p, Mat &tBw,const RECTS &tRects,double dbRatioTh,RECTS &tMergedRects)
{
	stLineSegmentationParam m_tLineSegmentationParam;
	initialSegmentationParam(m_tLineSegmentationParam);
	RECTS tRectsTmp;
	tRectsTmp = tRects;

	double xs,ys,xe,ye;
	int i,iNumBox;

	double xs1,ys1,xe1,ye1,xsm,ysm,xem,yem;
	double height1,width1,Ratio1,square1;
	double height2,width2,Ratio2,square2;
	double Uheight,Uwidth,Uratio;
	double Oheight,Owidth,Osquare;

	bool bVerticalOverlaped;
	bool bAreaOverlaped;
	bool bTooDiv;

	int j;
	int merged;

	Mat tImg1,tImg2,tImg3;

	double dbMinLow = 100000,dbMaxHight = 0;
	iNumBox = tRectsTmp.size();

	int bShow = 0;

	for( i=0; i<iNumBox; i++ )
	{

		xs = tRectsTmp[i].tTopLeft.x;
		ys = tRectsTmp[i].tTopLeft.y;
		xe = tRectsTmp[i].tButtomRight.x;
		ye = tRectsTmp[i].tButtomRight.y;   

		if ( (ys < dbMinLow) &&(ys > 0)  )
		{
			dbMinLow = ys;
		}
		if ( ye > dbMaxHight  )
		{
			dbMaxHight = ye;
		}

		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
		{
			continue;
		}

		//for( j=i+1; (j<i+2)&&(j<iNumBox); j++ )  //实际上应该只和周围的box合并
		for( j=i+1; j<iNumBox; j++ )  //实际上应该只和周围的box合并
		{

			xs = tRectsTmp[i].tTopLeft.x;
			ys = tRectsTmp[i].tTopLeft.y;
			xe = tRectsTmp[i].tButtomRight.x;
			ye = tRectsTmp[i].tButtomRight.y;   

			xs1 = tRectsTmp[j].tTopLeft.x;
			ys1 = tRectsTmp[j].tTopLeft.y;
			xe1 = tRectsTmp[j].tButtomRight.x;
			ye1 = tRectsTmp[j].tButtomRight.y;         

			if( (xs1 == 0) && (ys1 == 0) && (xe1 == 0) && (ye1 == 0) )
			{
				continue;
			}

			xsm = MIN(xs,xs1);
			xem = MAX(xe,xe1);
			ysm = MIN(ys,ys1);
			yem = MAX(ye,ye1);   

			// 			tImg1 = tBw(Range(ys,ye), Range(xs,xe));
			// 			tImg2 = tBw(Range(ys1,ye1), Range(xs1,xe1));
			// 			tImg3 = tBw(Range(ysm,yem), Range(xsm,xem));

			height1 = ye-ys+1;
			width1 = xe-xs+1;
			Ratio1 = width1 / height1;
			square1 = width1*height1;

			height2 = ye1-ys1+1;
			width2 = xe1-xs1+1;
			Ratio2 = width2 / height2;
			square2 = width2*height2;

			Uwidth = MAX(xe,xe1)-MIN(xs,xs1)+1;
			Uheight = MAX(ye,ye1)-MIN(ys,ys1)+1;

			Uratio = Uwidth / Uheight;

			Owidth = width1 + width2 - Uwidth ;
			Oheight = height1 + height2 - Uheight;

			Osquare = Owidth * Oheight;

			merged = 0;

			//bTooDiv = ((abs(width2-width1)/MAX(width1,width2)) > 0.6);
			bTooDiv = false;  /////wwf修改
			bVerticalOverlaped = ( (xs1 >= xs) && (xs1 <xe) || (xe1 > xs) && (xe1 <=xe) ) ;
			bAreaOverlaped    = ((Owidth > 0)&&(Oheight > 0));
			//bAreaOverlaped    = (Osquare > 0.8*MIN(square1,square2)) ||((Owidth > 0)&&(Oheight > 0));

			if (  (bAreaOverlaped || (bVerticalOverlaped && (!bTooDiv)) ) && 
				( (Uwidth<m_tLineSegmentationParam.lMaxWidth)&&(Uheight<m_tLineSegmentationParam.lMaxHigh) ) ) 
			{
				merged = 1;

			}// if (  bAreaOverlaped || verticaloverlaped ) 

			if( 1 == merged )
			{
				// 				if ( bShow == 1 )
				// 				{
				// 					ShowMat(tImg1,"1",true);
				// 					ShowMat(tImg2,"2",true);
				// 					ShowMat(tImg3,"3",true);
				// 				}

				tRectsTmp[i].tTopLeft.x     = xsm;
				tRectsTmp[i].tTopLeft.y     = ysm;
				tRectsTmp[i].tButtomRight.x = xem;
				tRectsTmp[i].tButtomRight.y = yem;   

				tRectsTmp[j].tTopLeft.x     = 0;
				tRectsTmp[j].tTopLeft.y     = 0;
				tRectsTmp[j].tButtomRight.x = 0;
				tRectsTmp[j].tButtomRight.y = 0;   

			}//if( 1 == merged )
			else
			{
				if ( bVerticalOverlaped && bTooDiv )
				{
					if ( width1 < width2 )
					{
						tRectsTmp[i].tTopLeft.x     = 0;
						tRectsTmp[i].tTopLeft.y     = 0;
						tRectsTmp[i].tButtomRight.x = 0;
						tRectsTmp[i].tButtomRight.y = 0;   
					}
					else
					{
						tRectsTmp[j].tTopLeft.x     = 0;
						tRectsTmp[j].tTopLeft.y     = 0;
						tRectsTmp[j].tButtomRight.x = 0;
						tRectsTmp[j].tButtomRight.y = 0;   
					}
				}//if ( bVerticalOverlaped && bTooDiv )

			}


		}//end% for j=i+1:numbox
	}//end % for i=1:numbox

	double dbRatio;
	bool bRet;
	RECTS tSubRects;
	int iNum;
	SHAPE_RECT tRect;

	tstring str;
	long dmin[10];
	double dbRank;
	double dbConfidence;

	for( i=0; i<iNumBox; i++ )
	{

		xs = tRectsTmp[i].tTopLeft.x;
		ys = tRectsTmp[i].tTopLeft.y;
		xe = tRectsTmp[i].tButtomRight.x;
		ye = tRectsTmp[i].tButtomRight.y;   

		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
		{
			continue;
		}

		//{
		//	Mat tDebuShow = tBw(Range(ys,ye+1),Range(xs,xe+1));
		//	bool bRet = OCREngine_Char(handle, iType, tDebuShow, str, dmin);
		//	
		//	destroyAllWindows();
		//	imshow("tmp", tDebuShow);

		//	waitKey();
		//	str.clear();
		//}
		

		dbRatio = (xe-xs+1)/(ye-ys+1);
		if( (dbRatio > dbRatioTh) && ((ye-ys+1)>5) )
		{
			Mat tBwchars = tBw(Range(ys,ye+1),Range(xs,xe+1));

			/*			ShowMat(tBwchars,"3",true);*/

			/*dbRank = m_pOCR->SearchChar(tBwchars,str,dmin);*/
			//OCREngine_Char(handle, iType, tBwchars,str,dmin);
			(*p)(handle, iType, tBwchars,str,dmin);
			dbRank = dmin[0];
			//dbConfidence = GetConfidence(m_tLineSegmentationParam.lMaxDist,m_tLineSegmentationParam.lDistRatio,dmin);
			dbConfidence = (double)dmin[0]/10000;

			str = str.substr(0,1);

			bRet = NoSegmentSpacialChar(str);
			//if ( (!bRet) || ((dbConfidence < 1)&&(dbRatio>2.4)) ) //有时候大串字符会被识别成“一”
			if ( (!bRet) || ((dbConfidence < 0.5)&&(dbRatio>2.4)) ) //有时候大串字符会被识别成“一”()
			{
				tSubRects.clear();
				bRet = SegmentByProfile(tBwchars,tSubRects);
				if ( bRet )
				{
					iNum = tSubRects.size();

					for( int j=0; j<iNum; j++) 
					{
						tRect.tTopLeft.x     = tSubRects[j].tTopLeft.x + xs;
						//tRect.tTopLeft.y     = dbMinLow;
						tRect.tTopLeft.y     = ys;
						tRect.tButtomRight.x = tSubRects[j].tButtomRight.x + xs;
						//tRect.tButtomRight.y = dbMaxHight;
						tRect.tButtomRight.y = ye;
						tMergedRects.push_back(tRect);

					}//for( int j=0; j<iNum; j++) 

					continue;

				}//if ( bRet )

			}//if ( !bRet )

		}//if( (dbRatio > dbRatioTh) && ((ye-ys+1)>5) )

		tRect.tTopLeft.x     = xs;
		//tRect.tTopLeft.y     = dbMinLow;
		tRect.tTopLeft.y     = ys;
		tRect.tButtomRight.x = xe;
		//tRect.tButtomRight.y = dbMaxHight;
		tRect.tButtomRight.y = ye;
		tMergedRects.push_back(tRect);

	}//for( i=0; i<iNumBox; i++ )

	return;
}

//void MergeOverlap_ID(long handle, int iType,/*MyOcrEngine p,*/ Mat &tGray,Mat &tBw,const RECTS &tRects,double dbRatioTh,RECTS &tMergedRects)
//{
//	stLineSegmentationParam m_tLineSegmentationParam;
//	initialSegmentationParam(m_tLineSegmentationParam);
//
//	npntr_ID_Engine* recEngine=(npntr_ID_Engine*)handle;//解析出IdCardOCR_v3.0引擎
//	
//	RECTS tRectsTmp;
//	tRectsTmp = tRects;
//
//	double xs,ys,xe,ye;
//	int i,iNumBox;
//
//	double xs1,ys1,xe1,ye1,xsm,ysm,xem,yem;
//	double height1,width1,Ratio1,square1;
//	double height2,width2,Ratio2,square2;
//	double Uheight,Uwidth,Uratio;
//	double Oheight,Owidth,Osquare;
//
//	bool bVerticalOverlaped;
//	bool bAreaOverlaped;
//	bool bTooDiv;
//
//	int j;
//	int merged;
//
//	Mat tImg1,tImg2,tImg3;
//
//	double dbMinLow = 100000,dbMaxHight = 0;
//	iNumBox = tRectsTmp.size();
//
//	int bShow = 0;
//
//	for( i=0; i<iNumBox; i++ )
//	{
//
//		xs = tRectsTmp[i].tTopLeft.x;
//		ys = tRectsTmp[i].tTopLeft.y;
//		xe = tRectsTmp[i].tButtomRight.x;
//		ye = tRectsTmp[i].tButtomRight.y;   
//
//		if ( (ys < dbMinLow) &&(ys > 0)  )
//		{
//			dbMinLow = ys;
//		}
//		if ( ye > dbMaxHight  )
//		{
//			dbMaxHight = ye;
//		}
//
//		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
//		{
//			continue;
//		}
//
//		//for( j=i+1; (j<i+2)&&(j<iNumBox); j++ )  //实际上应该只和周围的box合并
//		for( j=i+1; j<iNumBox; j++ )  //实际上应该只和周围的box合并
//		{
//
//			xs = tRectsTmp[i].tTopLeft.x;
//			ys = tRectsTmp[i].tTopLeft.y;
//			xe = tRectsTmp[i].tButtomRight.x;
//			ye = tRectsTmp[i].tButtomRight.y;   
//
//			xs1 = tRectsTmp[j].tTopLeft.x;
//			ys1 = tRectsTmp[j].tTopLeft.y;
//			xe1 = tRectsTmp[j].tButtomRight.x;
//			ye1 = tRectsTmp[j].tButtomRight.y;         
//
//			if( (xs1 == 0) && (ys1 == 0) && (xe1 == 0) && (ye1 == 0) )
//			{
//				continue;
//			}
//
//			xsm = MIN(xs,xs1);
//			xem = MAX(xe,xe1);
//			ysm = MIN(ys,ys1);
//			yem = MAX(ye,ye1);   
//
//			// 			tImg1 = tBw(Range(ys,ye), Range(xs,xe));
//			// 			tImg2 = tBw(Range(ys1,ye1), Range(xs1,xe1));
//			// 			tImg3 = tBw(Range(ysm,yem), Range(xsm,xem));
//
//			height1 = ye-ys+1;
//			width1 = xe-xs+1;
//			Ratio1 = width1 / height1;
//			square1 = width1*height1;
//
//			height2 = ye1-ys1+1;
//			width2 = xe1-xs1+1;
//			Ratio2 = width2 / height2;
//			square2 = width2*height2;
//
//			Uwidth = MAX(xe,xe1)-MIN(xs,xs1)+1;
//			Uheight = MAX(ye,ye1)-MIN(ys,ys1)+1;
//
//			Uratio = Uwidth / Uheight;
//
//			Owidth = width1 + width2 - Uwidth ;
//			Oheight = height1 + height2 - Uheight;
//
//			Osquare = Owidth * Oheight;
//
//			merged = 0;
//
//			//bTooDiv = ((abs(width2-width1)/MAX(width1,width2)) > 0.6);
//			bTooDiv = false;  /////wwf修改
//			bVerticalOverlaped = ( (xs1 >= xs) && (xs1 <xe) || (xe1 > xs) && (xe1 <=xe) ) ;
//			bAreaOverlaped    = ((Owidth > 0)&&(Oheight > 0));
//			//bAreaOverlaped    = (Osquare > 0.8*MIN(square1,square2)) ||((Owidth > 0)&&(Oheight > 0));
//
//			if (  (bAreaOverlaped || (bVerticalOverlaped && (!bTooDiv)) ) && 
//				( (Uwidth<m_tLineSegmentationParam.lMaxWidth)&&(Uheight<m_tLineSegmentationParam.lMaxHigh) ) ) 
//			{
//				merged = 1;
//
//			}// if (  bAreaOverlaped || verticaloverlaped ) 
//
//			if( 1 == merged )
//			{
//				// 				if ( bShow == 1 )
//				// 				{
//				// 					ShowMat(tImg1,"1",true);
//				// 					ShowMat(tImg2,"2",true);
//				// 					ShowMat(tImg3,"3",true);
//				// 				}
//
//				tRectsTmp[i].tTopLeft.x     = xsm;
//				tRectsTmp[i].tTopLeft.y     = ysm;
//				tRectsTmp[i].tButtomRight.x = xem;
//				tRectsTmp[i].tButtomRight.y = yem;   
//
//				tRectsTmp[j].tTopLeft.x     = 0;
//				tRectsTmp[j].tTopLeft.y     = 0;
//				tRectsTmp[j].tButtomRight.x = 0;
//				tRectsTmp[j].tButtomRight.y = 0;   
//
//			}//if( 1 == merged )
//			else
//			{
//				if ( bVerticalOverlaped && bTooDiv )
//				{
//					if ( width1 < width2 )
//					{
//						tRectsTmp[i].tTopLeft.x     = 0;
//						tRectsTmp[i].tTopLeft.y     = 0;
//						tRectsTmp[i].tButtomRight.x = 0;
//						tRectsTmp[i].tButtomRight.y = 0;   
//					}
//					else
//					{
//						tRectsTmp[j].tTopLeft.x     = 0;
//						tRectsTmp[j].tTopLeft.y     = 0;
//						tRectsTmp[j].tButtomRight.x = 0;
//						tRectsTmp[j].tButtomRight.y = 0;   
//					}
//				}//if ( bVerticalOverlaped && bTooDiv )
//
//			}
//
//
//		}//end% for j=i+1:numbox
//	}//end % for i=1:numbox
//
//	double dbRatio;
//	bool bRet;
//	RECTS tSubRects;
//	int iNum;
//	SHAPE_RECT tRect;
//
//	tstring str;
//	long dmin[10];
//	double dbRank;
//	double dbConfidence;
//
//	for( i=0; i<iNumBox; i++ )
//	{
//
//		xs = tRectsTmp[i].tTopLeft.x;
//		ys = tRectsTmp[i].tTopLeft.y;
//		xe = tRectsTmp[i].tButtomRight.x;
//		ye = tRectsTmp[i].tButtomRight.y;   
//
//		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
//		{
//			continue;
//		}
//
//		//{
//		//	Mat tDebuShow = tBw(Range(ys,ye+1),Range(xs,xe+1));
//		//	bool bRet = OCREngine_Char(handle, iType, tDebuShow, str, dmin);
//		//	
//		//	destroyAllWindows();
//		//	imshow("tmp", tDebuShow);
//
//		//	waitKey();
//		//	str.clear();
//		//}
//
//
//		dbRatio = (xe-xs+1)/(ye-ys+1);
//		if( (dbRatio > dbRatioTh) && ((ye-ys+1)>5) )
//		{
//			Mat tBwchars = tBw(Range(ys,ye+1),Range(xs,xe+1));
//			Mat tCombineChars=tGray(Range(ys,ye+1),Range(xs,xe+1));
//			vector<char>char_cnds;
//			vector<float>conf_cnds;
//			int cndNum=10;
//			/*			ShowMat(tBwchars,"3",true);*/
//
//			/*dbRank = m_pOCR->SearchChar(tBwchars,str,dmin);*/
//			//OCREngine_Char(handle, iType, tBwchars,str,dmin);
//			//(*p)(handle, iType, tBwchars,str,dmin);
//			if (iType==0)
//			{
//				recEngine->pEngine.charClassify(tCombineChars.data,tCombineChars.rows,tCombineChars.cols,1|2|8,cndNum,char_cnds,conf_cnds);
//			}
//			else
//			{
//				recEngine->pEngine.charClassify(tCombineChars.data,tCombineChars.rows,tCombineChars.cols,2|8,cndNum,char_cnds,conf_cnds);
//			}
//			for(int i=0;i<10;i++)
//			{
//				dmin[i]=((float)8-conf_cnds[i])*1250;
//			}
//			dbRank = dmin[0];
//			//dbConfidence = GetConfidence(m_tLineSegmentationParam.lMaxDist,m_tLineSegmentationParam.lDistRatio,dmin);
//			dbConfidence = (double)dmin[0]/10000;
//
//			//str = str.substr(0,1);
//			str=char_cnds[0];
//			bRet = NoSegmentSpacialChar(str);
//			//if ( (!bRet) || ((dbConfidence < 1)&&(dbRatio>2.4)) ) //有时候大串字符会被识别成“一”
//			if ( (!bRet) || ((dbConfidence < 0.5)&&(dbRatio>2.4)) ) 
//			{
//				tSubRects.clear();
//				bRet = SegmentByProfile(tBwchars,tSubRects);
//				if ( bRet )
//				{
//					iNum = tSubRects.size();
//
//					for( int j=0; j<iNum; j++) 
//					{
//						tRect.tTopLeft.x     = tSubRects[j].tTopLeft.x + xs;
//						//tRect.tTopLeft.y     = dbMinLow;
//						tRect.tTopLeft.y     = ys;
//						tRect.tButtomRight.x = tSubRects[j].tButtomRight.x + xs;
//						//tRect.tButtomRight.y = dbMaxHight;
//						tRect.tButtomRight.y = ye;
//						tMergedRects.push_back(tRect);
//
//					}//for( int j=0; j<iNum; j++) 
//
//					continue;
//
//				}//if ( bRet )
//
//			}//if ( !bRet )
//
//		}//if( (dbRatio > dbRatioTh) && ((ye-ys+1)>5) )
//
//		tRect.tTopLeft.x     = xs;
//		//tRect.tTopLeft.y     = dbMinLow;
//		tRect.tTopLeft.y     = ys;
//		tRect.tButtomRight.x = xe;
//		//tRect.tButtomRight.y = dbMaxHight;
//		tRect.tButtomRight.y = ye;
//		tMergedRects.push_back(tRect);
//
//	}//for( i=0; i<iNumBox; i++ )
//
//	return;
//}
void WeightedGraph(long handle, int iType,MyOcrEngine p, Mat &tImage,Mat &tBw,const RECTS &tRects,double dbRatioTh,Mat &G,Mat &W,Mat &CM,Mat &Labels,Mat &DMIN)
{
	stLineSegmentationParam m_tLineSegmentationParam;
	initialSegmentationParam(m_tLineSegmentationParam);
	int iNum = tRects.size();

	G = Mat::zeros(iNum+1,iNum+1, CV_32SC1);
	W = Mat::zeros(iNum+1,iNum+1, CV_64FC1);
	CM = Mat::zeros(iNum+1,iNum+1, CV_32SC1);
	Labels = Mat::zeros(iNum+1,iNum+1, CV_32SC1);
	DMIN   = Mat::zeros(iNum+1,iNum+1, CV_32SC1);

	int height = tBw.rows;
	int width  = tBw.cols;
	double xs,ys,xe,ye,xs1,ys1,xe1,ye1,xsm,xem,ysm,yem;
	double ratio;
	long dmin[10],dming[10];
	double dbRank;
	tstring str,strg,*pStr;
	long *pDim;

	double dbConfidence = 0;
	Mat tBwChar,tImgChar;

	Mat tImg1,tImg2,tImg3;

	int iDebugShow = 0;

	for(int i=0; i<iNum; i++) 
	{
		for(int j=i+1; j<(iNum+1);j++)
		{
			xs = tRects[i].tTopLeft.x ;
			ys = tRects[i].tTopLeft.y;
			xe = tRects[i].tButtomRight.x;
			ye = tRects[i].tButtomRight.y;   

			xs1 = tRects[j-1].tTopLeft.x ;
			ys1 = tRects[j-1].tTopLeft.y;
			xe1 = tRects[j-1].tButtomRight.x;
			ye1 = tRects[j-1].tButtomRight.y;   

			xsm = MIN(xs,xs1);
			xem = MAX(xe,xe1);
			ysm = MIN(ys,ys1);
			yem = MAX(ye,ye1);   

			ratio = (xem-xsm+1)/(yem-ysm+1);

			if( ( (ratio < dbRatioTh ) &&
				((yem-ysm)<m_tLineSegmentationParam.lMaxHigh) &&
				((xem-xsm)<m_tLineSegmentationParam.lMaxWidth) )||(i == (j-1)) )
			{

				G.at<int>(i,j) = 1;

				xs = xsm;
				xe = xem;
				ys = ysm;
				ye = yem;
				if ((xe <= xs) || (ye <= ys) )
				{
					continue;
				}

				tBwChar = tBw(Range(ys,ye+1),Range(xs,xe+1));

				(*p)(handle, iType, tBwChar,str,dmin);
				dbRank = dmin[0];

				dbConfidence = (double)dmin[0]/10000;
				for (int m = 0; m<10;++m)
				{
					dmin[m] = 10000-dmin[m];
				}

				if ( dbConfidence < 0.5 )
				{
					CM.at<int>(i,j) = 0;
					//str = _T("");
					W.at<double>(i,j) = dmin[0]*(j-i);
				}
				else
				{
					CM.at<int>(i,j) = 1;

					if( (i == (j-1) ) && (ratio < 0.7)&& IsChineseChar(str) )
					{
						W.at<double>(i,j) = dmin[0]*(j-i)*1.2;
					}
					else
					{
						//W.at<double>(i,j) = dmin[0]*(j-i)*0.8;
						W.at<double>(i,j) = dmin[0]*(j-i);
					}
				}

				pStr = new tstring;
				*pStr = str;
				Labels.at<int>(i,j) = (long)pStr;

				pDim = new long[10];
				memcpy(pDim,dmin,10*sizeof(long));
				DMIN.at<int>(i,j) = (long)pDim;

			}//if( ratio < ratioth )||(i == (j-1))

		}//%for j=i+1:num

	}//%for i=1:num

	double w,sum,maxw;

	for(int i=0; i<iNum; i++) 
	{
		for(int j=i+1; j<(iNum+1); j++ )
		{
			if( (G.at<int>(i,j) == 1) && ((j-i) > 1) )
			{
				w = W.at<double>(i,j) / (j-i) ;

				sum = 0;
				maxw = 0;

				for(int k=i; k<j; k++) 
				{
					sum = sum + W.at<double>(k,k+1);
					if( maxw < W.at<double>(k,k+1))
					{
						maxw = W.at<double>(k,k+1);
					}

				}//for k=i:j-1

				if( w < maxw )
				{
					//%W(i,j) = sum -1;
					W.at<double>(i,j) = w;
				}

			}

		}// %for j=i+1:num
	}//%for i=1:num
}

//void WeightedGraph_ID(long handle, int iType,/*MyOcrEngine p,*/ Mat &tImage,Mat &tBw,const RECTS &tRects,double dbRatioTh,Mat &G,Mat &W,Mat &CM,Mat &Labels,Mat &DMIN)
//{
//	stLineSegmentationParam m_tLineSegmentationParam;
//	initialSegmentationParam(m_tLineSegmentationParam);
//	int iNum = tRects.size();
//
//	npntr_ID_Engine* recEngine=(npntr_ID_Engine*)handle;//解析出IdCardOCR_v3.0引擎
//
//	G = Mat::zeros(iNum+1,iNum+1, CV_32SC1);
//	W = Mat::zeros(iNum+1,iNum+1, CV_64FC1);
//	CM = Mat::zeros(iNum+1,iNum+1, CV_32SC1);
//	Labels = Mat::zeros(iNum+1,iNum+1, CV_32SC1);
//	DMIN   = Mat::zeros(iNum+1,iNum+1, CV_32SC1);
//
//	int height = tBw.rows;
//	int width  = tBw.cols;
//	double xs,ys,xe,ye,xs1,ys1,xe1,ye1,xsm,xem,ysm,yem;
//	double ratio;
//	long dmin[10],dming[10];
//	double dbRank;
//	tstring str,strg,*pStr;
//	long *pDim;
//
//	double dbConfidence = 0;
//	Mat tBwChar,tImgChar,tCombinChar;
//
//	Mat tImg1,tImg2,tImg3;
//
//	int iDebugShow = 0;
//
//	for(int i=0; i<iNum; i++) 
//	{
//		for(int j=i+1; j<(iNum+1);j++)
//		{
//			xs = tRects[i].tTopLeft.x ;
//			ys = tRects[i].tTopLeft.y;
//			xe = tRects[i].tButtomRight.x;
//			ye = tRects[i].tButtomRight.y;   
//
//			xs1 = tRects[j-1].tTopLeft.x ;
//			ys1 = tRects[j-1].tTopLeft.y;
//			xe1 = tRects[j-1].tButtomRight.x;
//			ye1 = tRects[j-1].tButtomRight.y;   
//
//			xsm = MIN(xs,xs1);
//			xem = MAX(xe,xe1);
//			ysm = MIN(ys,ys1);
//			yem = MAX(ye,ye1);   
//
//			ratio = (xem-xsm+1)/(yem-ysm+1);
//
//			if( ( (ratio < dbRatioTh ) &&
//				((yem-ysm)<m_tLineSegmentationParam.lMaxHigh) &&
//				((xem-xsm)<m_tLineSegmentationParam.lMaxWidth) )||(i == (j-1)) )
//			{
//
//				G.at<int>(i,j) = 1;
//
//				xs = xsm;
//				xe = xem;
//				ys = ysm;
//				ye = yem;
//				if ((xe <= xs) || (ye <= ys) )
//				{
//					continue;
//				}
//
//				tBwChar = tBw(Range(ys,ye+1),Range(xs,xe+1));
//				tCombinChar=tImage(Range(ys,ye+1),Range(xs,xe+1));
//				vector<char>char_cnds;
//				vector<float>conf_cnds;
//				int cndNum=10;
//				/*			ShowMat(tBwchars,"3",true);*/
//
//				/*dbRank = m_pOCR->SearchChar(tBwchars,str,dmin);*/
//				//OCREngine_Char(handle, iType, tBwchars,str,dmin);
//				//(*p)(handle, iType, tBwchars,str,dmin);
//				if (iType==0)
//				{
//					recEngine->pEngine.charClassify(tCombinChar.data,tCombinChar.rows,tCombinChar.cols,1|2|8,cndNum,char_cnds,conf_cnds);
//				}
//				else
//				{
//					recEngine->pEngine.charClassify(tCombinChar.data,tCombinChar.rows,tCombinChar.cols,2|8,cndNum,char_cnds,conf_cnds);
//				}
//				//dbRank = dmin[0];
//				dbRank = ((float)8-conf_cnds[0])*1250;
//				dbConfidence = dbRank/10000;
//				for (int m = 0; m<10;++m)
//				{
//					//dmin[m] = 10000-dmin[m];
//					dmin[m] = 1250*conf_cnds[m];
//				}
//
//				if ( dbConfidence < 0.5 )
//				{
//					CM.at<int>(i,j) = 0;
//					//str = _T("");
//					W.at<double>(i,j) = dmin[0]*(j-i);
//				}
//				else
//				{
//					CM.at<int>(i,j) = 1;
//
//					if( (i == (j-1) ) && (ratio < 0.7)&& IsChineseChar(str) )
//					{
//						W.at<double>(i,j) = dmin[0]*(j-i)*1.2;
//					}
//					else
//					{
//						//W.at<double>(i,j) = dmin[0]*(j-i)*0.8;
//						W.at<double>(i,j) = dmin[0]*(j-i);
//					}
//				}
//
//				pStr = new tstring;
//				*pStr = str;
//				Labels.at<int>(i,j) = (long)pStr;
//
//				pDim = new long[10];
//				memcpy(pDim,dmin,10*sizeof(long));
//				DMIN.at<int>(i,j) = (long)pDim;
//
//			}//if( ratio < ratioth )||(i == (j-1))
//
//		}//%for j=i+1:num
//
//	}//%for i=1:num
//
//	double w,sum,maxw;
//
//	for(int i=0; i<iNum; i++) 
//	{
//		for(int j=i+1; j<(iNum+1); j++ )
//		{
//			if( (G.at<int>(i,j) == 1) && ((j-i) > 1) )
//			{
//				w = W.at<double>(i,j) / (j-i) ;
//
//				sum = 0;
//				maxw = 0;
//
//				for(int k=i; k<j; k++) 
//				{
//					sum = sum + W.at<double>(k,k+1);
//					if( maxw < W.at<double>(k,k+1))
//					{
//						maxw = W.at<double>(k,k+1);
//					}
//
//				}//for k=i:j-1
//
//				if( w < maxw )
//				{
//					//%W(i,j) = sum -1;
//					W.at<double>(i,j) = w;
//				}
//
//			}
//
//		}// %for j=i+1:num
//	}//%for i=1:num
//}
void ShortestPath(Mat &G,Mat &W,Mat &CM,vector<int> &tPhi)
{
	int iNum;
	iNum = G.rows;

	double inf = 10000000;

	vector<double> d(iNum);
	vector<int> phi(iNum);

	for ( int i=0; i<iNum; i++)
	{
		d[i] = inf;
		phi[i] = -1;
	}

	d[0] = 0;
	for(int u=0; u<(iNum-1); u++ )
	{
		for(int v=u+1; v<iNum; v++) 
		{
			if( G.at<int>(u,v) == 1)
			{
				if( d[v] > (d[u] + W.at<double>(u,v)) )
				{
					d[v]   = d[u] + W.at<double>(u,v);
					phi[v] = u;
				}

			}//if( G.at<int>(u,v) == 1)

		}//for j=i+1:num
	}//%for i=1:num-1

	tPhi = phi;
}

//识别税务登记证纳税类型切片内所有Rect
void SegmentAllRect(long handle, int iType, MyOcrEngine p,Mat &tImage,Mat &tBw,RECTS &tRects,stOcrRectList &tOcrRectList)
{
	stLineSegmentationParam m_tLineSegmentationParam;
	initialSegmentationParam(m_tLineSegmentationParam);
	tstring str;
	long dmin[10];
	for (int i=0;i<tRects.size();++i)
	{
		Rect tempRct;
		tempRct.x = tRects[i].tTopLeft.x;
		tempRct.y = tRects[i].tTopLeft.y;
		tempRct.width = tRects[i].tButtomRight.x - tRects[i].tTopLeft.x+1;
		tempRct.height = tRects[i].tButtomRight.y - tRects[i].tTopLeft.y+1;
		Mat tBwChar = Mat(tBw,tempRct);
		stOcrRect singleRect_OcrRect;
		(*p)(handle, iType, tBwChar,str,dmin);
		singleRect_OcrRect.dbConfidence = (double)dmin[0]/10000;
		singleRect_OcrRect.tRect = tRects[i];
		for (int j=0;j<10;++j)
		{
			singleRect_OcrRect.lDmin[j] = dmin[j];
		}
		//singleRect_OcrRect.lDmin = dmin;
		singleRect_OcrRect.strOcrResult = str;

		tOcrRectList.push_back(singleRect_OcrRect);
	}

	m_tLineSegmentationParam.bDebug=true;
	
	if ( m_tLineSegmentationParam.bDebug )
	{
		Mat tBwTmp;
		tBw.copyTo(tBwTmp);
		DrawBoxes(tBwTmp,tRects);
		/*imshow("tBwTmp",tBwTmp);
		waitKey();*/
		//ShowMat(tBwTmp,"MergeOverlap",true);
//imwrite("c:\\图像\\切割.jpg",tBwTmp);
	}
}

//判断某个Rect是否是标点（根据经验，标点在文字下方，或者在文字中间("-"),标点高度为字符高度的1/2.5）
bool IsRectPunc(const Mat tBw,int starty,int endy,RECTS tMergedRects,int index)
{
	Rect rc = Rect(tMergedRects[index].tTopLeft.x,tMergedRects[index].tTopLeft.y, tMergedRects[index].tButtomRight.x - tMergedRects[index].tTopLeft.x, tMergedRects[index].tButtomRight.y - tMergedRects[index].tTopLeft.y);
	Mat tmp = tBw(rc).clone();
	int charHeight = 0;
	int nTop = tmp.rows - 1;
	int nBot = 0;
	for (int i = 0; i < tmp.rows; i++)
	{
		for (int j = 0; j < tmp.cols; j++)
		{
			if (tmp.at<uchar>(i,j))
			{
				nTop = min(i,nTop);
				nBot = max(i, nBot);
			}
		}
	}
	if (nBot < nTop)
	{
		charHeight = 0;
	}
	else
	{
		charHeight = nBot - nTop + 1;
	}

	int RegionHeight = endy - starty;
	if(RegionHeight/2>charHeight)
	{
		if(index == 0)//满足高度小于相邻两个Rect高度的1/2.5，则可认为这是给标点
		{
			if(index+1>=tMergedRects.size())
				return false;
			int startHeight = tMergedRects[index+1].tButtomRight.y - tMergedRects[index+1].tTopLeft.y;
			if(startHeight/2.5 > charHeight)
				return true;
		}
		else if(index == tMergedRects.size()-1)
		{
			int endHeight = tMergedRects[index-1].tButtomRight.y - tMergedRects[index-1].tTopLeft.y;
			if((endHeight/2.5 > charHeight) && (tMergedRects[index].tButtomRight.y > (starty + endy)/2))
				return true;
		}
		else
		{
			int startHeight = tMergedRects[index+1].tButtomRight.y - tMergedRects[index+1].tTopLeft.y;
			int endHeight = tMergedRects[index-1].tButtomRight.y - tMergedRects[index-1].tTopLeft.y;
			if ((startHeight*0.6 >= charHeight && endHeight*0.6 >= charHeight)
				|| rc.y + nTop > tMergedRects[index+1].tButtomRight.y + startHeight * 0.4
				|| rc.y + nTop > tMergedRects[index+1].tButtomRight.y + endHeight * 0.4)
				return true;
		}
	}
	return false; 
}

void SegmentLine(long handle, int iType, MyOcrEngine p,Mat &tImage,Mat &tBw,RECTS &tRects,stOcrRectList &tOcrRectList)
{
	stLineSegmentationParam m_tLineSegmentationParam;
	initialSegmentationParam(m_tLineSegmentationParam);
	double dbRatioTh = m_tLineSegmentationParam.dbRatioTh;   //控制切分是否合并或分离的阈值
	if(iType==1||iType==3)
	{
		dbRatioTh =1.15;
	}
	RECTS tMergedRects;
	vector<int> tPhi;

	Mat G,W,CM,Labels,DMIN;

	Mat tBwTmp;

	//imshow("二值化",tBw);
	//waitKey();

	sort(tRects.begin(),tRects.end(),CmpRectByXPosAscend);


	MergeOverlap(handle, iType, p, tBw, tRects, dbRatioTh, tMergedRects);
	m_tLineSegmentationParam.bDebug=true;

	sort(tMergedRects.begin(),tMergedRects.end(),CmpRectByXPosAscend);

	/***************************************************************************************************/
	//判断某个Rect是否是标点符号			--
	stOcrRectList tOcrRectList_tmp;//文本行内所有被判别为标点的rect的临时贮藏
	Mat tBwCopy = tBw.clone();
	RECTS tMergedRects_new;
	if (iType==1)
	{
		int starty = 0;
		int endy = tBw.rows-1;
		Mat tReduce_x;
		reduce(tBw,tReduce_x,1,CV_REDUCE_SUM,CV_32FC1);
		for(int i = 0; i < tReduce_x.rows; i++)
		{
			if (abs(tReduce_x.at<float>(i,0)) <= 1)
				continue;
			else
			{
				starty = i;
				break;
			}
		}

		for(int i = tReduce_x.rows - 1; i >= 0; i--)
		{
			if (abs(tReduce_x.at<float>(i,0)) <= 1)
				continue;
			else
			{
				endy = i;
				break;
			}
		}

		//Mat tBwCopy = tBw.clone();
		//stOcrRectList tOcrRectList_tmp;//文本行内所有被判别为标点的rect的临时贮藏
		//RECTS tMergedRects_new;
		for(int i = 0; i < tMergedRects.size(); i++)
		{
			bool flag = IsRectPunc(tBw,starty,endy,tMergedRects,i);
			if(flag)
			{
				int charHeight = tMergedRects[i].tButtomRight.y-tMergedRects[i].tTopLeft.y;
				int charWidth = tMergedRects[i].tButtomRight.x-tMergedRects[i].tTopLeft.x;
				int x1 = tMergedRects[i].tTopLeft.x-charWidth*0.2 >= 0 ? tMergedRects[i].tTopLeft.x-charWidth*0.2 : 0;
				int y1 = tMergedRects[i].tTopLeft.y-charHeight*0.2 >= 0 ? tMergedRects[i].tTopLeft.y-charHeight*0.2 : 0;
				int x2 = tMergedRects[i].tButtomRight.x+charWidth*0.2 < tBw.cols ? tMergedRects[i].tButtomRight.x+charWidth*0.2 : tBw.cols - 2;
				int y2 = tMergedRects[i].tButtomRight.y+charHeight*0.2 < tBw.rows ? tMergedRects[i].tButtomRight.y+charHeight*0.2 : tBw.rows - 2;
				Rect tmpRect = Rect(Point(x1,y1),Point(x2,y2));
				rectangle(tBwCopy,tmpRect,Scalar(0),-1);
				stOcrRect tOcrRect_tmp;//判断为标点的临时储藏
				tOcrRect_tmp.tRect = tMergedRects[i];
				tOcrRect_tmp.strOcrResult = _T("");
				tOcrRectList_tmp.push_back(tOcrRect_tmp);//文本行内所有被判别为标点的rect的临时贮藏
			}
			else
				tMergedRects_new.push_back(tMergedRects[i]);
		}
	}
	else
	{
		tMergedRects_new=tMergedRects;
	}

	/***************************************************************************************************/

	WeightedGraph(handle, iType,p,tBwCopy,tBwCopy,tMergedRects_new,dbRatioTh,G,W,CM,Labels,DMIN);

	ShortestPath(G,W,CM,tPhi);

	int u,v;

	int iNum = tPhi.size();
	double xs,ys,xe,ye,xs1,ys1,xe1,ye1,xsm,ysm,xem,yem;
	stOcrRect tOcrRect;
	tstring * pStr = NULL;
	long * pDmin   = NULL;

	v = iNum-1;
	/***修改于2013-8-7防止进入死循环****/
	int flag=0;
	for (int i=0;i<iNum;i++)
	{
		if (tPhi[i]!=-1)   //如果全为-1则return
		{
			flag=1;
			break;
		}
	}
	if (flag==0)
	{
		return;
	}

	/**********/
	while ( v!=0 )
	{
		u = tPhi[v];
		if ( u == -1 )
		{
			v = v - 1; // 防止进入死循环
			continue;
		}

		xs = tMergedRects_new[u].tTopLeft.x;
		ys = tMergedRects_new[u].tTopLeft.y;
		xe = tMergedRects_new[u].tButtomRight.x;
		ye = tMergedRects_new[u].tButtomRight.y;

		xs1 = tMergedRects_new[v-1].tTopLeft.x;
		ys1 = tMergedRects_new[v-1].tTopLeft.y;
		xe1 = tMergedRects_new[v-1].tButtomRight.x;
		ye1 = tMergedRects_new[v-1].tButtomRight.y;

		xsm = MIN(xs, xs1);
		xem = MAX(xe, xe1);
		ysm = MIN(ys, ys1);
		yem = MAX(ye, ye1);  

		tOcrRect.tRect.tTopLeft.x = xsm;
		tOcrRect.tRect.tTopLeft.y = ysm;
		tOcrRect.tRect.tButtomRight.x = xem;
		tOcrRect.tRect.tButtomRight.y = yem;

		tOcrRect.lDist = (long)W.at<double>(u,v);
		tOcrRect.dbConfidence = CM.at<int>(u,v);

		pStr = (tstring *)Labels.at<int>(u,v);

		if ( NULL == pStr)
		{
			tOcrRect.strOcrResult = _T("");
		}
		else
		{
			tOcrRect.strOcrResult = *(pStr);
		}


		pDmin = (long *)DMIN.at<int>(u,v);
		if ( NULL == pDmin )
		{
			memset(tOcrRect.lDmin,110000,10*sizeof(long) );
		}
		else
		{
			memcpy(tOcrRect.lDmin,pDmin,10*sizeof(long) );
		}


		tOcrRectList.push_back(tOcrRect);

		v = u;

	}//while ( v!=0 )

	sort(tOcrRectList.begin(),tOcrRectList.end(),CmpOcrRectByXPosAscend);
	/*****切分的可靠性，增加于2013-10-31*********/
	// 	RECTS segRects;
	// 	stOcrRectList::iterator pos;
	// 
	// 	for (pos=tOcrRectList.begin();pos!=tOcrRectList.end();pos++)
	// 	{
	// 		SHAPE_RECT tmprect=pos->tRect;
	// 		segRects.push_back(tmprect);
	// 		
	// 	}
	//if ( m_tLineSegmentationParam.bDebug )
//	{
	//	tBw.copyTo(tBwTmp);
	//	DrawBoxes(tBwTmp,tMergedRects);
		//ShowMat(tBwTmp,"MergeOverlap",true);
	//	imwrite("c:\\切割.jpg",tBwTmp);
//	}

	/**************/

	long *pDim;
	pStr = NULL;

	for ( u=0; u<Labels.rows; u++)
	{
		for ( v=0; v<Labels.cols; v++)
		{
			pStr = (tstring *)Labels.at<int>(u,v);
			if ( NULL != pStr )
			{
				delete pStr;
				Labels.at<int>(u,v) = 0;
			} 
			pDim = (long *)DMIN.at<int>(u,v);
			if ( NULL != pDim )
			{
				delete [] pDim;
				DMIN.at<int>(u,v) = 0;
			}
		}
	}

	/*******************************************************/
	for(int i = 0; i < tOcrRectList_tmp.size(); i++)
		tOcrRectList.push_back(tOcrRectList_tmp[i]);

	sort(tOcrRectList.begin(),tOcrRectList.end(),CmpOcrRectByXPosAscend);
	/*******************************************************/
}

//void SegmentLine_ID(long handle, int iType, /*MyOcrEngine p,*/Mat &tImage,Mat &tBw,RECTS &tRects,stOcrRectList &tOcrRectList)//使用IdCardOCR_v3.0
//{
//	stLineSegmentationParam m_tLineSegmentationParam;
//	initialSegmentationParam(m_tLineSegmentationParam);
//	double dbRatioTh = m_tLineSegmentationParam.dbRatioTh;   //控制切分是否合并或分离的阈值
//	if(iType==1||iType==3)
//	{
//		dbRatioTh =1.15;
//	}
//	RECTS tMergedRects;
//	vector<int> tPhi;
//
//	Mat G,W,CM,Labels,DMIN;
//
//	Mat tBwTmp;
//
//	//imshow("二值化",tBw);
//	//waitKey();
//
//	sort(tRects.begin(),tRects.end(),CmpRectByXPosAscend);
//
//
//	MergeOverlap_ID(handle, iType,/* p,*/tImage, tBw, tRects, dbRatioTh, tMergedRects);
//	m_tLineSegmentationParam.bDebug=true;
//
//	sort(tMergedRects.begin(),tMergedRects.end(),CmpRectByXPosAscend);
//
//	/***************************************************************************************************/
//	//判断某个Rect是否是标点符号			--
//	stOcrRectList tOcrRectList_tmp;//文本行内所有被判别为标点的rect的临时贮藏
//	Mat tBwCopy = tBw.clone();
//	RECTS tMergedRects_new;
//	if (iType==1)
//	{
//		int starty = 0;
//		int endy = tBw.rows-1;
//		Mat tReduce_x;
//		reduce(tBw,tReduce_x,1,CV_REDUCE_SUM,CV_32FC1);
//		for(int i = 0; i < tReduce_x.rows; i++)
//		{
//			if (abs(tReduce_x.at<float>(i,0)) <= 1)
//				continue;
//			else
//			{
//				starty = i;
//				break;
//			}
//		}
//
//		for(int i = tReduce_x.rows - 1; i >= 0; i--)
//		{
//			if (abs(tReduce_x.at<float>(i,0)) <= 1)
//				continue;
//			else
//			{
//				endy = i;
//				break;
//			}
//		}
//
//		//Mat tBwCopy = tBw.clone();
//		//stOcrRectList tOcrRectList_tmp;//文本行内所有被判别为标点的rect的临时贮藏
//		//RECTS tMergedRects_new;
//		for(int i = 0; i < tMergedRects.size(); i++)
//		{
//			bool flag = IsRectPunc(tBw,starty,endy,tMergedRects,i);
//			if(flag)
//			{
//				int charHeight = tMergedRects[i].tButtomRight.y-tMergedRects[i].tTopLeft.y;
//				int charWidth = tMergedRects[i].tButtomRight.x-tMergedRects[i].tTopLeft.x;
//				int x1 = tMergedRects[i].tTopLeft.x-charWidth*0.2 >= 0 ? tMergedRects[i].tTopLeft.x-charWidth*0.2 : 0;
//				int y1 = tMergedRects[i].tTopLeft.y-charHeight*0.2 >= 0 ? tMergedRects[i].tTopLeft.y-charHeight*0.2 : 0;
//				int x2 = tMergedRects[i].tButtomRight.x+charWidth*0.2 < tBw.cols ? tMergedRects[i].tButtomRight.x+charWidth*0.2 : tBw.cols - 2;
//				int y2 = tMergedRects[i].tButtomRight.y+charHeight*0.2 < tBw.rows ? tMergedRects[i].tButtomRight.y+charHeight*0.2 : tBw.rows - 2;
//				Rect tmpRect = Rect(Point(x1,y1),Point(x2,y2));
//				rectangle(tBwCopy,tmpRect,Scalar(0),-1);
//				stOcrRect tOcrRect_tmp;//判断为标点的临时储藏
//				tOcrRect_tmp.tRect = tMergedRects[i];
//				tOcrRect_tmp.strOcrResult = _T("");
//				tOcrRectList_tmp.push_back(tOcrRect_tmp);//文本行内所有被判别为标点的rect的临时贮藏
//			}
//			else
//				tMergedRects_new.push_back(tMergedRects[i]);
//		}
//	}
//	else
//	{
//		tMergedRects_new=tMergedRects;
//	}
//
//	/***************************************************************************************************/
//
//	WeightedGraph_ID(handle, iType,/*p,*/tBwCopy,tBwCopy,tMergedRects_new,dbRatioTh,G,W,CM,Labels,DMIN);
//
//	ShortestPath(G,W,CM,tPhi);
//
//	int u,v;
//
//	int iNum = tPhi.size();
//	double xs,ys,xe,ye,xs1,ys1,xe1,ye1,xsm,ysm,xem,yem;
//	stOcrRect tOcrRect;
//	tstring * pStr = NULL;
//	long * pDmin   = NULL;
//
//	v = iNum-1;
//	/***修改于2013-8-7防止进入死循环****/
//	int flag=0;
//	for (int i=0;i<iNum;i++)
//	{
//		if (tPhi[i]!=-1)   //如果全为-1则return
//		{
//			flag=1;
//			break;
//		}
//	}
//	if (flag==0)
//	{
//		return;
//	}
//
//	/**********/
//	while ( v!=0 )
//	{
//		u = tPhi[v];
//		if ( u == -1 )
//		{
//			v = v - 1; // 防止进入死循环
//			continue;
//		}
//
//		xs = tMergedRects_new[u].tTopLeft.x;
//		ys = tMergedRects_new[u].tTopLeft.y;
//		xe = tMergedRects_new[u].tButtomRight.x;
//		ye = tMergedRects_new[u].tButtomRight.y;
//
//		xs1 = tMergedRects_new[v-1].tTopLeft.x;
//		ys1 = tMergedRects_new[v-1].tTopLeft.y;
//		xe1 = tMergedRects_new[v-1].tButtomRight.x;
//		ye1 = tMergedRects_new[v-1].tButtomRight.y;
//
//		xsm = MIN(xs, xs1);
//		xem = MAX(xe, xe1);
//		ysm = MIN(ys, ys1);
//		yem = MAX(ye, ye1);  
//
//		tOcrRect.tRect.tTopLeft.x = xsm;
//		tOcrRect.tRect.tTopLeft.y = ysm;
//		tOcrRect.tRect.tButtomRight.x = xem;
//		tOcrRect.tRect.tButtomRight.y = yem;
//
//		tOcrRect.lDist = (long)W.at<double>(u,v);
//		tOcrRect.dbConfidence = CM.at<int>(u,v);
//
//		pStr = (tstring *)Labels.at<int>(u,v);
//
//		if ( NULL == pStr)
//		{
//			tOcrRect.strOcrResult = _T("");
//		}
//		else
//		{
//			tOcrRect.strOcrResult = *(pStr);
//		}
//
//
//		pDmin = (long *)DMIN.at<int>(u,v);
//		if ( NULL == pDmin )
//		{
//			memset(tOcrRect.lDmin,110000,10*sizeof(long) );
//		}
//		else
//		{
//			memcpy(tOcrRect.lDmin,pDmin,10*sizeof(long) );
//		}
//
//
//		tOcrRectList.push_back(tOcrRect);
//
//		v = u;
//
//	}//while ( v!=0 )
//
//	sort(tOcrRectList.begin(),tOcrRectList.end(),CmpOcrRectByXPosAscend);
//	/*****
//	// 	RECTS segRects;
//	// 	stOcrRectList::iterator pos;
//	// 
//	// 	for (pos=tOcrRectList.begin();pos!=tOcrRectList.end();pos++)
//	// 	{
//	// 		SHAPE_RECT tmprect=pos->tRect;
//	// 		segRects.push_back(tmprect);
//	// 		
//	// 	}
//	//if ( m_tLineSegmentationParam.bDebug )
//	//	{
//	//	tBw.copyTo(tBwTmp);
//	//	DrawBoxes(tBwTmp,tMergedRects);
//	//ShowMat(tBwTmp,"MergeOverlap",true);
//	//	imwrite("c:\\切割.jpg",tBwTmp);
//	//	}
//
//	/**************/
//
//	long *pDim;
//	pStr = NULL;
//
//	for ( u=0; u<Labels.rows; u++)
//	{
//		for ( v=0; v<Labels.cols; v++)
//		{
//			pStr = (tstring *)Labels.at<int>(u,v);
//			if ( NULL != pStr )
//			{
//				delete pStr;
//				Labels.at<int>(u,v) = 0;
//			} 
//			pDim = (long *)DMIN.at<int>(u,v);
//			if ( NULL != pDim )
//			{
//				delete [] pDim;
//				DMIN.at<int>(u,v) = 0;
//			}
//		}
//	}
//
//	/*******************************************************/
//	for(int i = 0; i < tOcrRectList_tmp.size(); i++)
//		tOcrRectList.push_back(tOcrRectList_tmp[i]);
//
//	sort(tOcrRectList.begin(),tOcrRectList.end(),CmpOcrRectByXPosAscend);
//	/*******************************************************/
//}
void SegmentLine(long handle, int iType,MyOcrEngine p, Mat &tImage,Mat &tBw,stOcrRectList &tOcrRectList)
{
	stLineSegmentationParam m_tLineSegmentationParam;
	initialSegmentationParam(m_tLineSegmentationParam);
	int iPixelTh = m_tLineSegmentationParam.iPixelTh;
	double dbRatioTh = m_tLineSegmentationParam.dbRatioTh;   //控制切分是否合并或分离的阈值
	if(iType==1||iType==3)
	{
		dbRatioTh =1.15;
	}

	RECTS tRects;
	RECTS tMergedRects;
	vector<int> tPhi;

	Mat G,W,CM,Labels,DMIN;

	ConnComponent(tBw,iPixelTh,tRects);
	sort(tRects.begin(),tRects.end(),CmpRectByXPosAscend);

	Mat tBwTmp;
	// 	tBw.copyTo(tBwTmp);
	// 	DrawBoxes(tBwTmp,tRects);
	// 	ShowMat(tBwTmp,"ConnComponent");

	MergeOverlap(handle, iType, p,tBw,tRects,dbRatioTh,tMergedRects);

	tBw.copyTo(tBwTmp);
	DrawBoxes(tBwTmp,tMergedRects);
//	ShowMat(tBwTmp,"MergeOverlap");


	sort(tMergedRects.begin(),tMergedRects.end(),CmpRectByXPosAscend);

	WeightedGraph(handle, iType,p, tImage,tBw,tMergedRects,dbRatioTh,G,W,CM,Labels,DMIN);

	ShortestPath(G,W,CM,tPhi);

	int u,v;

	int iNum = tPhi.size();
	double xs,ys,xe,ye,xs1,ys1,xe1,ye1,xsm,ysm,xem,yem;
	stOcrRect tOcrRect;

	v = iNum-1;

	while ( v!=0 )
	{
		u = tPhi[v];
		if ( u == -1 )
		{
			continue;
		}

		xs = tMergedRects[u].tTopLeft.x;
		ys = tMergedRects[u].tTopLeft.y;
		xe = tMergedRects[u].tButtomRight.x;
		ye = tMergedRects[u].tButtomRight.y;

		xs1 = tMergedRects[v-1].tTopLeft.x;
		ys1 = tMergedRects[v-1].tTopLeft.y;
		xe1 = tMergedRects[v-1].tButtomRight.x;
		ye1 = tMergedRects[v-1].tButtomRight.y;

		xsm = MIN(xs, xs1);
		xem = MAX(xe, xe1);
		ysm = MIN(ys, ys1);
		yem = MAX(ye, ye1);  

		tOcrRect.tRect.tTopLeft.x = xsm;
		tOcrRect.tRect.tTopLeft.y = ysm;
		tOcrRect.tRect.tButtomRight.x = xem;
		tOcrRect.tRect.tButtomRight.y = yem;

		tOcrRect.lDist = (long)W.at<double>(u,v);
		tOcrRect.strOcrResult = *((tstring *)Labels.at<int>(u,v));

		memcpy(tOcrRect.lDmin,(long *)DMIN.at<int>(u,v),10*sizeof(long) );

		tOcrRectList.push_back(tOcrRect);

		v = u;

	}//while ( v!=0 )

	sort(tOcrRectList.begin(),tOcrRectList.end(),CmpOcrRectByXPosAscend);

	tstring *pStr;
	long *pDim;

	for ( u=0; u<Labels.rows; u++)
	{
		for ( v=0; v<Labels.cols; v++)
		{
			pStr = (tstring *)Labels.at<int>(u,v);
			if ( NULL != pStr )
			{
				delete pStr;
				Labels.at<int>(u,v) = 0;
			} 
			pDim = (long *)DMIN.at<int>(u,v);
			if ( NULL != pDim )
			{
				delete [] pDim;
				DMIN.at<int>(u,v) = 0;
			}
		}
	}

}

void ConnComponent(Mat &tBw,int iPixelTh,RECTS &tRects)
{
	vector<vector<Point>> contours;
	vector<Vec4i> hierarchy;

	Mat tBwImageTmp;
	tBw.copyTo(tBwImageTmp);

	findContours(tBwImageTmp, contours , hierarchy , CV_RETR_TREE , CV_CHAIN_APPROX_NONE,Point(0, 0)); //查找连通区域

	double dbArea = 0;
	SHAPE_RECT tRect;
	double dbRatio;

	int iNum = 0;

	if (!contours.empty())
	{
		for (int idx=0;idx>=0;idx=hierarchy[idx][0])
		{
			Rect cBoundingBox = boundingRect(Mat(contours[idx]));

			Mat tRectImg = tBw(Range(cBoundingBox.y,cBoundingBox.y + cBoundingBox.height-1), 
				Range(cBoundingBox.x,cBoundingBox.x + cBoundingBox.width-1));

			//ShowMat(tRectImg);

			dbArea = contourArea(contours[idx]);
			dbRatio = double(cBoundingBox.width) / double(cBoundingBox.height);

			if( ( dbArea < iPixelTh ) && (dbRatio >0.3) && (dbRatio < 3) )
			{
				continue;
			}


			/*			ShowMat(tRectImg,"conn",true);*/

			tRect.tTopLeft.x = cBoundingBox.x;
			tRect.tTopLeft.y = cBoundingBox.y;
			tRect.tButtomRight.x = tRect.tTopLeft.x + cBoundingBox.width-1;
			tRect.tButtomRight.y = tRect.tTopLeft.y + cBoundingBox.height-1;
			tRects.push_back(tRect);

			//iNum++;
			//sprintf(ch,"%d",iNum);
			//string str = "Connection";
			//str = str + ch;
			//ShowMat(tRectImg,str);

		}//for (int idx=0;idx>=0;idx=hierarchy[idx][0])
	}//if (!contours.empty())

	return;
}

double GetConfidence(long lMaxDist,double dbDistRatio,long dmin[10])
{
	/*DEBUG("");*/
	long lMin2 = 0;

	if ( abs(dmin[2]) > 0 )
	{
		lMin2 = dmin[2];
	}
	else if ( abs(dmin[1]) > 0 )
	{
		lMin2 = dmin[1];
	}
	else
	{
		lMin2 = long(double(dmin[0])/double((3*dmin[0]+1)));
	}

	if( (dmin[0] > lMaxDist)
		||( double(dmin[0])/double(lMin2) > dbDistRatio ) )
	{
		/*DEBUG("D");*/
		return 0;
	}
	else
	{
		/*DEBUG("D");*/
		return 1;
	}
	//DEBUG("");
	//return ( double(10000-dmin[0])/double(10000) );
}

void RunLength(Mat &tBwImage,int val,vector<int> &LH,vector<int> &LV)
{
	//[m,n] = size(bw);
	/*DEBUG("");*/
	int iHeight = tBwImage.rows;
	int iWidth  = tBwImage.cols;
	int iMaxLen = MAX(iHeight,iWidth);

	LH.resize(iMaxLen+1);
	LV.resize(iMaxLen+1);

	for(int i=0; i<(iMaxLen+1);i++) 
	{
		LH[i] = 0;
		LV[i] = 0;
	}

	int state = 0;
	int len   = 0;
	int lastp = 1;
	int i,j;

	for(int i=0; i<iHeight;i++) 
	{
		state = 0;
		len   = 0;
		lastp = 1;

		for(int j=0; j<iWidth; j++ ) 
		{

			if(state == 0)
			{
				if( tBwImage.at<uchar>(i,j) == val )
				{
					state = 1;
					lastp = j;
				}
			}
			else
			{
				if( tBwImage.at<uchar>(i,j) != val )
				{
					state = 0;
					len = j-lastp;
					LH[len] = LH[len]+1;
				}

			}//if(state == 0) else

		}//for(int j=0; j<iWidth; j++ ) 

	}//for(int i=0; i<iHeight;i++) 


	for( j=0; j<iWidth; j++ )
	{

		state = 0;
		len   = 0;
		lastp = 1;

		for(i=0; i<iHeight; i++) 
		{

			if(state == 0)
			{
				if( tBwImage.at<uchar>(i,j) == val )
				{
					state = 1;
					lastp = i;
				}   
			}
			else
			{
				if( tBwImage.at<uchar>(i,j) != val )
				{
					state = 0;
					len = i-lastp;
					LV[len] = LV[len]+1;
				}
			}//if(state == 0) else
		}//for(i=0; i<iHeight; i++) 

	}//for( j=0; j<iWidth; j++ )
	/*DEBUG("");*/
	return;

	// 	int maxhlen = 0;
	// 	for(i=iMaxLen; i>0; i-- ) //i=maxlen:-1:1
	// 	{
	// 		if( LH1(i) > 0 )
	// 		{
	// 			maxhlen = i;
	// 			break;
	// 		}
	// 
	// 	}//for(i=iMaxLen; i>0; i-- )
	// 
	// 	int	maxvlen = 0;
	// 	for(i=iMaxLen; i>0; i-- ) //i=maxlen:-1:1
	// 	{
	// 
	// 		if( LV1(i) > 0 )
	// 		{
	// 			maxvlen = i;
	// 			break;
	// 		}
	// 
	// 	}//for(i=iMaxLen; i>0; i-- )
	// 
	// 	int	maxhvlen = MAX(maxhlen,maxvlen);
	// 
	// 	LH = LH(1:maxhvlen);
	// 	LV = LV(1:maxhvlen);

}

void GetRunLengthStat(Mat &tBwImage,int &iASWF,int &iASWB)
{
	/*DEBUG("");*/
	vector<int> tLHForeground,tLVForeground,tLHBackground,tLVBackground;
	int iForegroundVal = 255; 
	int iBackgroundVal = 0; 

	RunLength(tBwImage,iForegroundVal,tLHForeground,tLVForeground);
	RunLength(tBwImage,iBackgroundVal,tLHBackground,tLVBackground);

	//int iASWF,iASWB;
	int iMaxRLF=0,iMaxRLFIdx=0,iMaxRLB=0,iMaxRLBIdx=0;

	int iLen = tLHForeground.size();
	vector<int> tRLForeground(iLen),tRLBackground(iLen);

	iMaxRLF = 0;
	iMaxRLB = 0;

	for ( int i= 0; i<iLen; i++ )
	{
		tRLForeground[i] = tLHForeground[i]+tLVForeground[i];
		tRLBackground[i] = tLHBackground[i]+tLVBackground[i];

		if ( tRLForeground[i] > iMaxRLF )
		{
			iMaxRLF    = tRLForeground[i];
			iMaxRLFIdx = i;
		}

		if ( tRLBackground[i] > iMaxRLB )
		{
			iMaxRLB    = tRLBackground[i];
			iMaxRLBIdx = i;
		}

	}//for ( int i= 0; i<iLen; i++ )

	iASWF = iMaxRLFIdx;
	iASWB = iMaxRLBIdx;
	/*DEBUG("");*/
}

int IsSalt(Mat &tBw,int iPixelTh)
{
	/*DEBUG("");*/
	vector<vector<Point>> contours;
	vector<Vec4i> hierarchy;

	Mat tBwImageTmp;
	tBw.copyTo(tBwImageTmp);

	findContours(tBwImageTmp, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
	//findContours(tBwImageTmp, contours , hierarchy , CV_RETR_TREE , CV_CHAIN_APPROX_NONE,Point(0, 0)); //查找连通区域


	double dbArea = 0;
	SHAPE_RECT tRect;

	int iNum = 0;

	if (!contours.empty())
	{
		//for (int idx=0;idx>=0;idx=hierarchy[idx][0])
		for (int idx=0;idx<contours.size();idx++)
		{
			Rect cBoundingBox = boundingRect(Mat(contours[idx]));

			Mat tRectImg = tBw(Range(cBoundingBox.y,cBoundingBox.y + cBoundingBox.height), 
				Range(cBoundingBox.x,cBoundingBox.x + cBoundingBox.width));

			//ShowMat(tRectImg);

			dbArea = contourArea(contours[idx]);

			if ( dbArea < iPixelTh )
			{
				iNum++;
				continue;
			}

			/*			ShowMat(tRectImg,"conn",true);*/

		}//for (int idx=0;idx>=0;idx=hierarchy[idx][0])
	}//if (!contours.empty())

	/*DEBUG("Done");*/
	return iNum;

}

void RunRectLength(const RECTS &tRect,int iWidth,int &iASWR)
{
	/*DEBUG("");*/
	vector<int> L(iWidth);

	int iSpan;

	if ( tRect.size() < 2)
	{
		iASWR = 0;
		return;
	}

	for(int i=0; i<iWidth;i++) 
	{
		L[i] = 0;
	}

	for(int i=0; i<tRect.size()-1;i++) 
	{
		iSpan = int(tRect[i+1].tTopLeft.x - tRect[i].tButtomRight.x);
		if ( iSpan >= 0 )
		{
			L[iSpan]++;
		}

	}//for(int i=0; i<iHeight;i++) 

	vector<int>::iterator pos = max_element(L.begin(),L.end());

	iASWR = distance(L.begin(),pos);

	/*DEBUG("");*/
	return;

}

bool FilterSmallDot(Mat &tImage,Mat &tBwImage,int &iASWF,int &iASWB,int &iASWR)
{
	Mat tBw;
	tBwImage.copyTo(tBw);
	Mat tBw1;
	tBw1 = tBw;
	//medianBlur ( tBw, tBw1, 3 );

	GetRunLengthStat(tBw1,iASWF,iASWB);

	if ( (0==iASWF) || (0==iASWB) )
	{
		return false;
	}

	int iSum = IsSalt(tBw,10);
	if ( iSum > 50 )
	{
		medianBlur ( tBw, tBw1, 3 );

		tBw = tBw1;
	}
	RECTS tRects;
	vector<double> tConnAreas;
	Mat tFilledImg = tBw;

	int iMinArea = MAX(iASWF*iASWF,4);
	iMinArea = MIN(iASWF*iASWF,10);

	if ( BINARY_DENBW == m_iBwMethod)
	{
		ConnComponent(tBw,iMinArea,tRects,tConnAreas,false,0,tFilledImg);
	}
	else
	{
		ConnComponent(tBw,1,tRects,tConnAreas,true,0,tFilledImg);
	}

	tBwImage = tFilledImg;

	sort(tRects.begin(),tRects.end(),CmpRectByXPosAscend);

	RunRectLength(tRects,tBw.cols,iASWR);
	GetRunLengthStat(tFilledImg,iASWF,iASWB);

	return true;

}

void MergeRectByOverlap(const RECTS &tRects,RECTS &tMergedRects,double dbOverlapTh)
{
	/*DEBUG("");*/
	RECTS tRectsTmp;
	tRectsTmp = tRects;

	double xs,ys,xe,ye;
	int i,iNumBox;

	double xs1,ys1,xe1,ye1,xsm,ysm,xem,yem;
	double height1,width1,Ratio1,square1;
	double height2,width2,Ratio2,square2;
	double Uheight,Uwidth,Uratio;
	double Oheight,Owidth,Osquare;

	bool bVerticalOverlaped;
	bool bAreaOverlaped;
	bool bTooDiv;

	int j;
	int merged;

	double dbMinLow = 100000,dbMaxHight = 0;
	iNumBox = tRectsTmp.size();
	/*DEBUG("");*/
	for( i=0; i<iNumBox; i++ )
	{

		xs = tRectsTmp[i].tTopLeft.x;
		ys = tRectsTmp[i].tTopLeft.y;
		xe = tRectsTmp[i].tButtomRight.x;
		ye = tRectsTmp[i].tButtomRight.y;   

		if ( (ys < dbMinLow) &&(ys > 0)  )
		{
			dbMinLow = ys;
		}
		if ( ye > dbMaxHight  )
		{
			dbMaxHight = ye;
		}

		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
		{
			continue;
		}

		//for( j=i+1; (j<i+2)&&(j<iNumBox); j++ )  //实际上应该只和周围的box合并
		for( j=i+1; j<iNumBox; j++ )  //实际上应该只和周围的box合并
		{

			xs = tRectsTmp[i].tTopLeft.x;
			ys = tRectsTmp[i].tTopLeft.y;
			xe = tRectsTmp[i].tButtomRight.x;
			ye = tRectsTmp[i].tButtomRight.y;   

			xs1 = tRectsTmp[j].tTopLeft.x;
			ys1 = tRectsTmp[j].tTopLeft.y;
			xe1 = tRectsTmp[j].tButtomRight.x;
			ye1 = tRectsTmp[j].tButtomRight.y;         

			if( (xs1 == 0) && (ys1 == 0) && (xe1 == 0) && (ye1 == 0) )
			{
				continue;
			}

			xsm = MIN(xs,xs1);
			xem = MAX(xe,xe1);
			ysm = MIN(ys,ys1);
			yem = MAX(ye,ye1);   

			height1 = ye-ys+1;
			width1 = xe-xs+1;
			Ratio1 = width1 / height1;
			square1 = width1*height1;

			height2 = ye1-ys1+1;
			width2 = xe1-xs1+1;
			Ratio2 = width2 / height2;
			square2 = width2*height2;

			Uwidth = MAX(xe,xe1)-MIN(xs,xs1)+1;
			Uheight = MAX(ye,ye1)-MIN(ys,ys1)+1;

			Uratio = Uwidth / Uheight;

			Owidth = width1 + width2 - Uwidth ;
			Oheight = height1 + height2 - Uheight;

			Osquare = Owidth * Oheight;

			merged = 0;

			//bAreaOverlaped    = ((Owidth > 0)&&(Oheight > 0));
			bAreaOverlaped    = ((Owidth > 1)&&(Oheight > 1));

			if ( (bAreaOverlaped) && 
				/*((Osquare / MIN(square1,square2)) > dbOverlapTh) &&*/		// 
				( abs(height1-height2) < 5*MIN(height1,height2)) &&
				( abs(width1-width2) < 5*MIN(width1,width2))
				) 
			{
				merged = 1;

			}// if (  bAreaOverlaped  ) 

			if( 1 == merged )
			{

				tRectsTmp[i].tTopLeft.x     = xsm;
				tRectsTmp[i].tTopLeft.y     = ysm;
				tRectsTmp[i].tButtomRight.x = xem;
				tRectsTmp[i].tButtomRight.y = yem;   

				tRectsTmp[j].tTopLeft.x     = 0;
				tRectsTmp[j].tTopLeft.y     = 0;
				tRectsTmp[j].tButtomRight.x = 0;
				tRectsTmp[j].tButtomRight.y = 0;   

			}//if( 1 == merged )

		}//end% for j=i+1:numbox
	}//end % for i=1:numbox
	/*DEBUG("");*/
	tMergedRects.clear();

	SHAPE_RECT tRect;
	for( i=0; i<iNumBox; i++ )
	{

		xs = tRectsTmp[i].tTopLeft.x;
		ys = tRectsTmp[i].tTopLeft.y;
		xe = tRectsTmp[i].tButtomRight.x;
		ye = tRectsTmp[i].tButtomRight.y;   

		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
		{
			continue;
		}


		tRect.tTopLeft.x     = xs;
		tRect.tTopLeft.y     = ys;
		tRect.tButtomRight.x = xe;
		tRect.tButtomRight.y = ye;
		tMergedRects.push_back(tRect);

	}//for( i=0; i<iNumBox; i++ )
	/*DEBUG("D");*/
	return;
}

void StatRect(const RECTS &tRects,RECTS &tRectsFiltered,double &dbAveWidth,double &dbAveHigh,double &dbAveRatio,double &dbAveDist,double &dbAveCenterX,double &dbAveCenterY)
{
	double dbWidth,dbHeight,dbCenterX,dbCenterY,dbRatio;
	SHAPE_RECT tPrevRect;

	int i;

	dbAveWidth = 0;
	dbAveHigh  = 0;
	dbAveRatio = 0;
	dbAveDist  = 0;
	dbAveCenterX = 0;
	dbAveCenterY = 0;

	double dbNum;

	for( i=0; i<tRects.size(); i++ )
	{
		dbNum = i;

		ComputeRect(tRects[i],dbHeight,dbWidth,dbRatio,dbCenterX,dbCenterY);

		/*dbAveHigh   = dbAveHigh * (dbNum-1) /dbNum +  dbHeight * (1/dbNum);                                   
		dbAveWidth  = dbAveWidth * (dbNum-1) /dbNum +  dbWidth  * (1/dbNum);                                   
		dbAveRatio  = dbAveRatio  * (dbNum-1) /dbNum +  dbRatio  * (1/dbNum);                                   
		dbAveCenterX  = dbAveCenterX  * (dbNum-1) /dbNum +  dbCenterX  * (1/dbNum);
		dbAveCenterY  = dbAveCenterY  * (dbNum-1) /dbNum +  dbCenterY  * (1/dbNum);*/

		double dbDist,dbPrevWidth,dbPrevHeight,dbPrevCenterX,dbPrevCenterY,dbPrevRatio;
		if ( i > 1 )
		{
			ComputeRect(tPrevRect,dbPrevHeight,dbPrevWidth,dbPrevRatio,dbPrevCenterX,dbPrevCenterY);

			dbDist = dbCenterX - dbPrevCenterX;

			if ( dbDist > (dbAveWidth/2)*0.9  )
			{
				dbAveDist = dbAveDist  * (dbNum-1) /dbNum +  dbDist  * (1/dbNum);
				//lujin modified at 2013.12.25,如果一个rect与上一个rect的间距大于前一个rect的5倍宽度，就把后面的rect都过滤掉了
				/*if ( dbDist > dbAveDist * 5 )
				{
					break;
				}*/

			}


		}//if ( i > 1 )

		tPrevRect = tRects[i];

		tRectsFiltered.push_back(tRects[i]);

	}

	return;

}

void FilterDot(Mat &tBw,int iPixelTh,uchar cFillVal)
{
	vector<vector<Point>> contours;
	vector<Vec4i> hierarchy;

	Mat tBwImageTmp;
	tBw.copyTo(tBwImageTmp);


	findContours(tBwImageTmp, contours , hierarchy , CV_RETR_LIST|CV_RETR_EXTERNAL , CV_CHAIN_APPROX_NONE,Point(0, 0)); //查找连通区域


	double dbArea = 0;
	Rect tRect;

	int iNum = 0;

	if (!contours.empty())
	{
		//for (int idx=0;idx>=0;idx=hierarchy[idx][0])
		for (int idx=0;idx<contours.size();idx++)
		{
			Rect cBoundingBox = boundingRect(Mat(contours[idx]));

			dbArea = contourArea(contours[idx]);

			if ( (dbArea < iPixelTh) ||
				(cBoundingBox.width <=2) ||
				(cBoundingBox.height <=2)
				)
			{
				// 				Point pt;
				// 				for ( int i=0; i<contours[idx].size(); i++ )
				// 				{
				// 					pt = contours[idx][i];
				// 					tBw.at<uchar>(pt.y,pt.x) = cFillVal;
				// 				}

				Point2f pt;
				double dbRet;

				for ( int m=cBoundingBox.x; m<cBoundingBox.x+cBoundingBox.width; m++ )
				{
					for ( int n=cBoundingBox.y; n<cBoundingBox.y+cBoundingBox.height; n++ )
					{
						if ( tBw.at<uchar>(n,m) == 255 )
						{
							pt.x = m;
							pt.y = n;

							dbRet = pointPolygonTest(contours[idx],pt,false);
							if ( dbRet >=0 )
							{
								tBw.at<uchar>(n,m) = cFillVal;
							}

						}//if ( tDigitBw.at<uchar>(n,m) == 255 )

					}//for ( int n=cBoundingBox.y; n<cBoundingBox.y+cBoundingBox.height; n++ )
				}//for ( int m=cBoundingBox.x; m<cBoundingBox.x+cBoundingBox.width; m++ )

			}

		}//for (int idx=0;idx>=0;idx=hierarchy[idx][0])
	}//if (!contours.empty())

	return;
}

//过滤Rect，将宽高比不满足0.2~5或者宽度高度小于一定值的Rect去掉
bool FiltRect(RECTS &tRects,double dbRatio1,double dbRatio2,int widthThreshold,int heightThreshold)
{
	RECTS tRectsCopy;
	double tempwidth,tempheight;
	if(tRects.empty())
		return false;
	for (int i=0; i<tRects.size();++i)
	{
		tempwidth = tRects[i].tButtomRight.x - tRects[i].tTopLeft.x+1;
		tempheight = tRects[i].tButtomRight.y - tRects[i].tTopLeft.y+1;
		if(tempwidth/tempheight>dbRatio1&&tempwidth/tempheight<dbRatio2&&tempwidth>widthThreshold&&tempheight>heightThreshold)
		{
			tRectsCopy.push_back(tRects[i]);
		}

	}
	if(tRectsCopy.size()==0)
		return false;
	else
	{
		tRects.clear();
		tRects = tRectsCopy;
		return true;
	}
	

}

//统计切片内所有Rect的宽度、高度的中值。对于宽高比不满足0.2~5的Rect不参与统计。
bool StatRectMiddleValue(RECTS &tRects,int &middleWidth,int &middleHeight)
{
	vector<int> width,height;
	double tempwidth,tempheight = 0;
	if(tRects.size()==0)
		return false;
	
	for (int i=0; i<tRects.size();++i)
	{
		tempwidth = tRects[i].tButtomRight.x - tRects[i].tTopLeft.x+1;
		tempheight = tRects[i].tButtomRight.y - tRects[i].tTopLeft.y+1;
		width.push_back(tempwidth);
		height.push_back(tempheight);
		
	}
	if(width.size()==0||height.size()==0)
		return false;
	sort(width.begin(),width.end());
	sort(height.begin(),height.end());
	middleWidth = width[width.size()/2];
	middleHeight = height[height.size()/2];
	return true;
}

//针对纳税类型的预处理
bool ProcessTaxType(Mat &tImage,Mat &tBwImage,RECTS &tRects)
{
	Mat bw_copy = tBwImage.clone();
	Mat dilatebw;
	FilterDot(bw_copy,15,0);
	//medianBlur(bw_copy,bw_copy,3);
	Mat kernel = (Mat_<uchar>(3,3)<<1,1,1,
									1,1,1,
									1,1,1

					);


	dilate(bw_copy,dilatebw,kernel ,Point(-1,-1),2);
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;
	findContours(dilatebw,contours,hierarchy,CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0,0));
	if(0==contours.size())
	{
		return false;
	}
			  
	//findContours(soreImg,contours,hierarchy,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_SIMPLE, Point(0,0));
	//findContours(soreImg,contours,hierarchy,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_NONE, Point(0,0));

	vector<Rect> boundRect( contours.size() );

	for (int i=0; i< contours.size(); i++)
	{
		//approxPolyDP( Mat(contours[i]),contours_poly[i], 3, true );
		boundRect[i] = boundingRect( Mat(contours[i]) );
		
	}
	for (int i=0;i<boundRect.size();++i)
	{
		SHAPE_RECT tempRect;
		SHAPE_POINT tempPoint;
		tempPoint.x = boundRect[i].x;
		tempPoint.y = boundRect[i].y;
		tempRect.tTopLeft = tempPoint;

		tempPoint.x = boundRect[i].x+boundRect[i].width-1;
		tempPoint.y = boundRect[i].y+boundRect[i].height-1;
		tempRect.tButtomRight = tempPoint;
		
		tRects.push_back(tempRect);
	}
	if(!FiltRect(tRects,0.2,5,20,20))
		return false;
	int middleWideth,middleHeight;
	StatRectMiddleValue(tRects,middleWideth,middleHeight);
	RECTS NewRects1,NewRects2;

	//将高度太大的Rect切成两个Rect
	for (int i=0;i<tRects.size();++i)
	{
		int width,height;
		double dbRatio;
		width = tRects[i].tButtomRight.x-tRects[i].tTopLeft.x+1;
		height = tRects[i].tButtomRight.y-tRects[i].tTopLeft.y+1;
		dbRatio = (double)height/width;

		if(height>middleHeight*1.6||dbRatio>1.6)
		{
			SHAPE_RECT tempRect1,tempRect2;
			SHAPE_POINT tempPoint;
			tempPoint.x = tRects[i].tTopLeft.x;
			tempPoint.y = tRects[i].tTopLeft.y;
			tempRect1.tTopLeft = tempPoint;
			tempPoint.x = tRects[i].tButtomRight.x;
			tempPoint.y = (tRects[i].tTopLeft.y + tRects[i].tButtomRight.y)/2;
			tempRect1.tButtomRight = tempPoint;

			tempPoint.x = tRects[i].tTopLeft.x;
			tempPoint.y = (tRects[i].tTopLeft.y + tRects[i].tButtomRight.y)/2;
			tempRect2.tTopLeft = tempPoint;
			tempPoint.x = tRects[i].tButtomRight.x;
			tempPoint.y = tRects[i].tButtomRight.y;
			tempRect2.tButtomRight = tempPoint;

			NewRects1.push_back(tempRect1);
			NewRects1.push_back(tempRect2);

		}
		else
		{
			NewRects1.push_back(tRects[i]);
		}
	}

	//将宽度太大的Rect切成两个Rect
	for (int i=0;i<NewRects1.size();++i)
	{
		int width,height;
		double dbRatio;
		width = NewRects1[i].tButtomRight.x-NewRects1[i].tTopLeft.x+1;
		height = NewRects1[i].tButtomRight.y-NewRects1[i].tTopLeft.y+1;
		dbRatio = (double)width/height;
		if((width>middleWideth*1.4&&width<middleWideth*2.4)||(dbRatio>1.4&&dbRatio<2.4))
		{
			SHAPE_RECT tempRect1,tempRect2;
			SHAPE_POINT tempPoint;
			tempPoint.x = NewRects1[i].tTopLeft.x;
			tempPoint.y = NewRects1[i].tTopLeft.y;
			tempRect1.tTopLeft = tempPoint;
			tempPoint.x = (NewRects1[i].tTopLeft.x + NewRects1[i].tButtomRight.x)/2;
			tempPoint.y = NewRects1[i].tButtomRight.y;
			tempRect1.tButtomRight = tempPoint;

			tempPoint.x = (NewRects1[i].tTopLeft.x + NewRects1[i].tButtomRight.x)/2;
			tempPoint.y = NewRects1[i].tTopLeft.y;
			tempRect2.tTopLeft = tempPoint;
			tempPoint.x = NewRects1[i].tButtomRight.x;
			tempPoint.y = NewRects1[i].tButtomRight.y;
			tempRect2.tButtomRight = tempPoint;

			NewRects2.push_back(tempRect1);
			NewRects2.push_back(tempRect2);

		}
		else if ((width>middleWideth*2.4&&width<middleWideth*3.4)||(dbRatio>2.4&&dbRatio<3.4))
		{
			SHAPE_RECT tempRect1,tempRect2,tempRect3;
			SHAPE_POINT tempPoint;
			tempPoint.x = NewRects1[i].tTopLeft.x;
			tempPoint.y = NewRects1[i].tTopLeft.y;
			tempRect1.tTopLeft = tempPoint;
			tempPoint.x = (2*NewRects1[i].tTopLeft.x + NewRects1[i].tButtomRight.x)/3;
			tempPoint.y = NewRects1[i].tButtomRight.y;
			tempRect1.tButtomRight = tempPoint;

			tempPoint.x = (2*NewRects1[i].tTopLeft.x + NewRects1[i].tButtomRight.x)/3;
			tempPoint.y = NewRects1[i].tTopLeft.y;
			tempRect2.tTopLeft = tempPoint;
			tempPoint.x = (NewRects1[i].tTopLeft.x + 2*NewRects1[i].tButtomRight.x)/3;
			tempPoint.y = NewRects1[i].tButtomRight.y;
			tempRect2.tButtomRight = tempPoint;

			tempPoint.x = (NewRects1[i].tTopLeft.x + 2*NewRects1[i].tButtomRight.x)/3;
			tempPoint.y = NewRects1[i].tTopLeft.y;
			tempRect3.tTopLeft = tempPoint;
			tempPoint.x = NewRects1[i].tButtomRight.x;
			tempPoint.y = NewRects1[i].tButtomRight.y;
			tempRect3.tButtomRight = tempPoint;

			NewRects2.push_back(tempRect1);
			NewRects2.push_back(tempRect2);
			NewRects2.push_back(tempRect3);

		}
		else
		{
			NewRects2.push_back(NewRects1[i]);
		}
	}

	if(!NewRects2.empty())
	{
		tRects.clear();
		tRects = NewRects2;
		return true;
	}
	else
		return false;

}

bool Process(Mat &tImage,Mat &tBwImage,Mat &tConnBwImage,RECTS &tRects)
{
	//imshow("k",tImage);
	//waitKey();
	bool bRet;
	int iASWF,iASWB,iASWR;

	int height = tImage.rows;
	int width  = tImage.cols;

	//bool bLowQuality = IsLowQuality(tImage);
	//if ( bLowQuality )
	//{
	//	double dbGamma = 2;
	//	ImAdjust(tImage,dbGamma);
	//}
	//

	Mat tBw = tBwImage.clone();
	bRet = FilterSmallDot(tImage,tBw,iASWF,iASWB,iASWR);

	/***增加于2013-10-10,进来的行图像要旋转矫正，避免对后续分割识别的影响***/
	/*Mat rotateBw;
	totat2(tBw,rotateBw);
	tBw=rotateBw;*/

	
	/********/
	if ( !bRet )
	{
		return false;
	}

	RECTS tPreRects;

	//if ( (bLowQuality)&&(m_bEnhance)&&(height>9)&&(width>9)&&(iASWF<4) )
	//if ( (bLowQuality)&&(height>9)&&(width>9)&&(iASWF<4) )
	//{
	//	bRet = EnhanceBw(tImage,tConnBwImage);
	//	if ( !bRet )
	//	{
	//		tConnBwImage = tBw;
	//	}

	//    CombineBwConn(tImage,tConnBwImage,iASWF,tPreRects);

	//}
	/*else
	{*/
		tConnBwImage = tBw;

		GetRunLengthStat(tConnBwImage,iASWF,iASWB);

		vector<double> tConnAreas;
		Mat tFilledImg = tConnBwImage;
		
		ConnComponent(tConnBwImage,1,tPreRects,tConnAreas,true,0,tFilledImg);
		//imshow("111",tFilledImg);
		//waitKey();
		
		/*
		}*/

	int iRectHigh,iRectWidth;

	sort(tPreRects.begin(),tPreRects.end(),CmpRectByXPosAscend);

	RECTS tMergedRects;
	double dbOverlapTh = 0.5;

	MergeRectByOverlap(tPreRects,tMergedRects,dbOverlapTh);
	tPreRects.clear();
	MergeRectByOverlap(tMergedRects,tPreRects,dbOverlapTh);
	sort(tPreRects.begin(),tPreRects.end(),CmpRectByXPosAscend);

	double dbAveWidth,dbAveHigh,dbAveRatio,dbAveDist,dbAveCenterX,dbAveCenterY;

	StatRect(tPreRects,tRects,dbAveWidth,dbAveHigh,dbAveRatio,dbAveDist,dbAveCenterX,dbAveCenterY);

	
	tBwImage = tConnBwImage;   //直接赋值没有真正的完成后处理

	/**************

	tBwImage=Mat::zeros(tConnBwImage.size(),tConnBwImage.type());
	SHAPE_RECT tmp_rect;
	for (int i=0;i<tRects.size();i++)
	{
		 tmp_rect=tRects[i];
		 Mat roiImage=tConnBwImage(Range(int(tmp_rect.tTopLeft.y),int(tmp_rect.tButtomRight.y)),
			                       Range(int(tmp_rect.tTopLeft.x),int(tmp_rect.tButtomRight.x)));
		 for (int m=(int)tmp_rect.tTopLeft.y;m<(int)tmp_rect.tButtomRight.y;m++)
		 {
			 for (int n=(int)tmp_rect.tTopLeft.x;n<(int)tmp_rect.tButtomRight.x;n++)
			 {
				 if (tConnBwImage.at<uchar>(m,n)==255)
				 {
					 tBwImage.at<uchar>(m,n)=255;
				 }
			 }
		 }
	}
   ********************************************************************/
	
	
	return true;

}

//bool ProcessNoBin(Mat &tImage,Mat &tBwImage,Mat &tConnBwImage,RECTS &tRects)//输入的为二值化图，有效像素为黑色
//{
//
//
//
//	bool bRet;
//	int iASWF,iASWB,iASWR;
//
//	int height = tImage.rows;
//	int width  = tImage.cols;
//	tConnBwImage=255-tImage;
//	/***进入切分识别模块的tLineBw还需要做一次倾斜矫正,修改于2013-9-11***/
//	Mat rotateBw;
//	totat2(tConnBwImage,rotateBw);
//	tConnBwImage=rotateBw;
//	/*********/
//
//
//	GetRunLengthStat(tConnBwImage,iASWF,iASWB);
//
//	RECTS tPreRects;
//	vector<double> tConnAreas;
//	Mat tFilledImg = tConnBwImage;
//	ConnComponent(tConnBwImage,iASWF*iASWF,tPreRects,tConnAreas,true,0,tFilledImg);
//
//	
//	int iRectHigh,iRectWidth;
//
//	sort(tPreRects.begin(),tPreRects.end(),CmpRectByXPosAscend);
//
//	RECTS tMergedRects;
//	double dbOverlapTh = 0.5;
//
//	MergeRectByOverlap(tPreRects,tMergedRects,dbOverlapTh);
//	tPreRects.clear();
//	MergeRectByOverlap(tMergedRects,tPreRects,dbOverlapTh);
//	sort(tPreRects.begin(),tPreRects.end(),CmpRectByXPosAscend);
//
//	double dbAveWidth,dbAveHigh,dbAveRatio,dbAveDist,dbAveCenterX,dbAveCenterY;
//
//	StatRect(tPreRects,tRects,dbAveWidth,dbAveHigh,dbAveRatio,dbAveDist,dbAveCenterX,dbAveCenterY);
//
//	tBwImage = tConnBwImage;
//	
//
//	return true;
//
//}

//bool IsLowQuality(const Mat &tImage)
//{
//	/*DEBUG("");*/
//	int bins = 256;
//	int histSize[] = {bins};
//	float granges[] = { 0, 255 };
//	const float* ranges[] = { granges};
//	int channels[] = {0};
//	MatND hist;
//
//	calcHist( &tImage, 1, channels, Mat(),hist, 1, histSize, ranges,true,false );
//
//	int    iVal = 100;
//
//	double dbLow = 0,dbTotal = 0;
//	for ( int i=0; i<bins; i++ )
//	{
//
//		if ( i < iVal )
//		{
//			dbLow = dbLow + hist.at<float>(i,0);
//		}
//
//		dbTotal = dbTotal + hist.at<float>(i,0);
//
//	}//for ( int i=0; i<bins; i++ )
//
//	//double dbTh = 0.08;
//	double dbTh = 0.02;
//	double dbRatio = dbLow/dbTotal;
//	if ( dbRatio < dbTh )
//	{
//		/*DEBUG("True");*/
//		return true;
//	} 
//	else
//	{
//		/*DEBUG("False");*/
//		return false;
//	}
//
//
//}
//
//void ImAdjust(Mat &tImage,double dbGamma)
//{
//	/*DEBUG("");*/
//	double low    =  0;
//	double high   = 255;
//	double bottom = 0;
//	double top    = 255;
//	double err_in = high-low;
//	double err_out = top-bottom;
//
//	int x,y;
//	double val;
//
//	int iHigh,iWidth;
//
//	iHigh  = tImage.rows;
//	iWidth = tImage.cols;
//
//	for ( y=0; y<iHigh; y++ )
//	{
//		for ( x=0; x<iWidth; x++ )
//		{
//			if ( tImage.channels() == 3 )
//			{
//				for ( int k=0; k<tImage.channels(); k++ )
//				{
//					val = tImage.at<Vec3b>(y,x)[k];
//
//					val = pow( (val-low)/err_in,dbGamma )*err_out+bottom;
//
//					if ( val > 255 )
//					{
//						val = 255;
//					}
//					if ( val < 0 )
//					{
//						val = 0;
//					}
//
//					tImage.at<Vec3b>(y,x)[k] = (uchar)val;
//				}
//
//			}
//			else
//			{
//				val = tImage.at<uchar>(y,x);
//
//				val = pow( (val-low)/err_in,dbGamma )*err_out+bottom;
//
//				if ( val > 255 )
//				{
//					val = 255;
//				}
//				if ( val < 0 )
//				{
//					val = 0;
//				}
//
//				tImage.at<uchar>(y,x) = (uchar)val;
//
//			}
//		}
//	}//for ( y=0; y<iHigh; y++ )
//
//	/*DEBUG("Done");*/
//	return;
//}




//bool CombineBwConn(Mat &tImage,Mat &tBw,int iASWF,RECTS &tRects)
//{
//	double dbRatioTh = 1.25;
//	ConnComponentByNiblack(tImage,tBw,iASWF,dbRatioTh,tRects);
//
//	return true;
//
//}

void totat2(cv::Mat& bina_in,cv::Mat& out_bina)
{
	bina_in.copyTo(out_bina);
	Mat rot_mat( 2, 3, CV_32FC1 );
	Point center = Point( bina_in.cols/2, bina_in.rows/2 );
	double scale = 1;

	Mat canny1,canny2;
	//imshow("bina_in",bina_in);
	waitKey();
	Canny(bina_in,canny1,50,150,3);
	canny1.copyTo(canny2);
	int i1=0,j1=0,k1=0,i2=0,j2=0,k2=0;
	int sealwidth=bina_in.cols;
	int sealheight=bina_in.rows;

	int maxnum=0;
	int tempx=0;
	int tempy=0;
	int edgenum=0;
	float temp1=0,temp2=0,angleend=0;

	for(i1=0;i1<sealheight;i1++)
	{
		for(j1=1;j1<(sealwidth-1);j1++)
		{
			int coor=i1*sealwidth+j1;
			if(canny1.data[coor-1]==255||canny1.data[coor+1]==255)
			{
				canny2.data[coor]=0;
			}
			else
			{
				if(canny1.data[coor]==255)
				{
					tempx =tempx+j1;
					tempy =tempy+i1;
					edgenum++;
				}

			}
		}
	}
	if(edgenum>0)
	{
		tempx=tempx/edgenum;
		tempy=tempy/edgenum;
		for(i1=0;i1<sealheight;i1++)
		{
			for(j1=1;j1<(sealwidth-1);j1++)
			{
				int coor=i1*sealwidth+j1;
				if(canny2.data[coor]==255)
				{
					temp1=temp1+(j1-tempx)*(j1-tempx);
					temp1=temp1-(i1-tempy)*(i1-tempy);
					temp2=temp2+2*(i1-tempy)*(j1-tempx);
				}
			}
		}
		if(temp1>0)
		{
			angleend = (float)(atan(temp2/temp1) *180/ CV_PI )/2;
		}
	}
	/// Get the rotation matrix with the specifications above
	//color_img.copyTo(out_color);
	if(fabs(angleend)<=15&&angleend!=0)
	{
		rot_mat = getRotationMatrix2D( center, angleend, scale );//计算仿射变换矩阵，正值表示逆时针旋
		Mat warp_mat( 2, 3, CV_32FC1 );

		Mat warp_dst = Mat::zeros( bina_in.rows, bina_in.cols,bina_in.type());
		//Mat warp_color=Mat::zeros( color_img.rows, color_img.cols,color_img.type());
		Mat dst;
		warpAffine( out_bina, warp_dst,rot_mat,warp_dst.size(),1,0,cv::Scalar(0,0,0)  );//做仿射变换
		//warpAffine( out_color, warp_color,rot_mat,warp_color.size(),1,0,cv::Scalar(255,255,255)  );//做仿射变换

		threshold(warp_dst,out_bina,0,255,CV_THRESH_OTSU);
		//out_color=warp_color;


	}
	return;

}

void RotateRectByAngle(const ANGLE_RECT &tRect,int iHeight,int iWidth,double dbAngle,ANGLE_RECT &tRectRatated)
{
	/*DEBUG("");*/
	double height,width;
	height = double(iHeight);
	width = double(iWidth);

	double x1,y1,x2,y2,x3,y3,x4,y4;

	x1 = tRect.tP1.x - width/2; 
	y1 = tRect.tP1.y - height/2;
	x2 = tRect.tP2.x - width/2; 
	y2 = tRect.tP2.y - height/2;
	x3 = tRect.tP3.x - width/2;
	y3 = tRect.tP3.y - height/2;
	x4 = tRect.tP4.x - width/2;
	y4 = tRect.tP4.y - height/2;

	Mat ROT,X,Xr;
	ROT.create(2,2, CV_64FC1);
	X.create(2,4,CV_64FC1);
	Xr.create(2,4,CV_64FC1);

	ROT.at<double>(0,0) = cosd(dbAngle);
	ROT.at<double>(0,1) = sind(dbAngle);
	ROT.at<double>(1,0) = -1*sind(dbAngle);
	ROT.at<double>(1,1) = cosd(dbAngle);

	//ROT = [cosd(angle)    sind(angle)
	//	-1*sind(angle) cosd(angle)];

	X.at<double>(0,0) = x1;
	X.at<double>(0,1) = x2;
	X.at<double>(0,2) = x3;
	X.at<double>(0,3) = x4;
	X.at<double>(1,0) = y1;
	X.at<double>(1,1) = y2;
	X.at<double>(1,2) = y3;
	X.at<double>(1,3) = y4;
	/*DEBUG("");*/
	Xr = ROT * X;

	tRectRatated.tP1.x = Xr.at<double>(0,0) + width/2;
	tRectRatated.tP2.x = Xr.at<double>(0,1) + width/2;
	tRectRatated.tP3.x = Xr.at<double>(0,2) + width/2;
	tRectRatated.tP4.x = Xr.at<double>(0,3) + width/2;
	/*DEBUG("");*/
	tRectRatated.tP1.y = Xr.at<double>(1,0) + height/2;
	tRectRatated.tP2.y = Xr.at<double>(1,1) + height/2;
	tRectRatated.tP3.y = Xr.at<double>(1,2) + height/2;
	tRectRatated.tP4.y = Xr.at<double>(1,3) + height/2;

	/*DEBUG("D");*/
	return;

}

//bool BinarizationN(Mat &tImage,Mat &tBwImage)
//{
//	Mat tBw(tImage.size(),tImage.type());
//
//	int iRet = fyBinarization(tImage,tBw,BINARY_NIBLACK,9,9);
//	tBw = 255-tBw;
//	if ( iRet < 0 )
//	{
//		return false;
//	}
//
//	int iHigh  = tImage.rows;
//	int iWidth = tImage.cols;
//
//	vector<Point2i> tPointList(iHigh*iWidth);
//	int iPointNum = 0;
//	int i,j;
//	uchar ucFrontVal = 255;
//
//	for ( i=0; i<iHigh; i++ )
//	{
//		for ( j=0; j<iWidth; j++ )
//		{
//			if ( tBw.at<uchar>(i,j) == ucFrontVal )
//			{
//				tPointList[iPointNum].x = j;
//				tPointList[iPointNum].y = i;
//				iPointNum++;
//			}
//		}
//	}//for ( i=0; i<iHigh; i++ )
//
//	Mat tSamples(iPointNum,1,CV_32FC1);
//	int row,col;
//	for ( i=0; i<iPointNum; i++ )
//	{
//		row = tPointList[i].y;
//		col = tPointList[i].x;
//		tSamples.at<float>(i,0) = tImage.at<uchar>(row,col);
//	}
//
//	Mat tLabels = Mat::zeros(iPointNum,1,CV_32SC1);
//	int clusterCount = 2;
//	TermCriteria criteria;
//	int attempts = 2;
//	int flags = KMEANS_PP_CENTERS;
//	Mat centers;
//
//	criteria.type = CV_TERMCRIT_EPS+CV_TERMCRIT_ITER;
//	criteria.maxCount = 100;
//	criteria.epsilon  = 1.0;
//
//
//	kmeans(tSamples,clusterCount,tLabels,criteria,attempts,flags,centers);
//
//	int iFrontLabel = 0;
//
//	if ( centers.at<float>(0,0) > centers.at<float>(1,0) )
//	{
//		iFrontLabel = 1;
//	} 
//
//
//	tBwImage = Mat::zeros(iHigh,iWidth,CV_8UC1);
//
//	int iLabel;
//
//	for ( i=0; i<iPointNum; i++ )
//	{
//		row = tPointList[i].y;
//		col = tPointList[i].x;
//
//		iLabel = tLabels.at<int>(i,0);
//
//		if ( iFrontLabel == iLabel )
//		{
//			tBwImage.at<uchar>(row,col) = 255;
//		}
//	}
//
//	return true;
//}

//void ImGeoFeature(Mat &tImage,Mat &tImGeoLabel)
//{
//	Mat tG0,tG1,tG2,tG3,tG4,tG5,tG6,tG7;
//
//	Gradient8(tImage,tG0,tG1,tG2,tG3,tG4,tG5,tG6,tG7);
//
//	Mat tDirectionLabel0,tDirectionLabel1,tDirectionLabel2,tDirectionLabel3,tMainDirection;
//
//	Direction(tG0,tG1,tG2,tG3,tG4,tG5,tG6,tG7,tDirectionLabel0,tDirectionLabel1,
//		tDirectionLabel2,tDirectionLabel3,tMainDirection);
//
//	//Mat tImGeoLabel;
//	GeoFeature(tDirectionLabel0,tDirectionLabel1,tDirectionLabel2,tDirectionLabel3,tMainDirection,tImGeoLabel);
//
//	return;
//}

//void Gradient8(Mat &tImage,Mat &tG0,Mat &tG1,Mat &tG2,Mat &tG3,Mat &tG4,Mat &tG5,Mat &tG6,Mat &tG7)
//{
//	Mat I = 255 - tImage;
//
//	//I = double(I);
//
//	int m = I.rows;
//	int n = I.cols;
//
//	Mat tGArray[8];
//
//	tGArray[0] = Mat::zeros(m,n,CV_64FC1);
//	tGArray[1] = Mat::zeros(m,n,CV_64FC1);
//	tGArray[2] = Mat::zeros(m,n,CV_64FC1);
//	tGArray[3] = Mat::zeros(m,n,CV_64FC1);
//	tGArray[4] = Mat::zeros(m,n,CV_64FC1);
//	tGArray[5] = Mat::zeros(m,n,CV_64FC1);
//	tGArray[6] = Mat::zeros(m,n,CV_64FC1);
//	tGArray[7] = Mat::zeros(m,n,CV_64FC1);
//
//	int Nx[]    = {1,   0, -1, -1, -1,  0,  1,  1};
//	int Ny[]    = {-1, -1, -1,  0,  1,  1,  1,  0};
//	double Nd[] = {D2,  1, D2,  1, D2,  1, D2,  1};
//	int i,j,k;
//
//	for( i=1; i<m-1; i++ )
//	{
//		for( j=1; j<n-1; j++) 
//		{
//			for( k=0; k<8; k++) 
//			{
//
//				if( k < 4 )
//				{
//					tGArray[k].at<double>(i,j) = ((double)I.at<uchar>(i,j) - (double)I.at<uchar>(i+Ny[k],j+Nx[k])) / Nd[k];
//				}
//				else
//				{
//					tGArray[k].at<double>(i,j) = ( (double)I.at<uchar>(i+Ny[k],j+Nx[k]) - (double)I.at<uchar>(i,j) ) / Nd[k];
//				}
//
//			}//for( k=1; k<9; k++) 
//
//		}
//	}//for( i=1; i<m-1; i++ )
//
//	tG0 = tGArray[0];
//	tG1 = tGArray[1];
//	tG2 = tGArray[2];
//	tG3 = tGArray[3];
//	tG4 = tGArray[4];
//	tG5 = tGArray[5];
//	tG6 = tGArray[6];
//	tG7 = tGArray[7];
//
//	return;
//
//
//}

//void Direction(Mat &tG0,Mat &tG1,Mat &tG2,Mat &tG3,Mat &tG4,Mat &tG5,Mat &tG6,Mat &tG7,Mat &tDirectionLabel0,
//	Mat &tDirectionLabel1,Mat &tDirectionLabel2,Mat &tDirectionLabel3,Mat &tMainDirection)
//{
//
//	int m = tG0.rows;
//	int n = tG0.cols;
//
//	Mat tGArray[8];
//
//	tGArray[0] = tG0;
//	tGArray[1] = tG1;
//	tGArray[2] = tG2;
//	tGArray[3] = tG3;
//	tGArray[4] = tG4;
//	tGArray[5] = tG5;
//	tGArray[6] = tG6;
//	tGArray[7] = tG7;
//
//	Mat DirectionLabelArray[4];
//
//	DirectionLabelArray[0] = GEO_OTHER * Mat::ones(m,n,CV_64FC1);
//	DirectionLabelArray[1] = GEO_OTHER * Mat::ones(m,n,CV_64FC1);
//	DirectionLabelArray[2] = GEO_OTHER * Mat::ones(m,n,CV_64FC1);
//	DirectionLabelArray[3] = GEO_OTHER * Mat::ones(m,n,CV_64FC1);
//
//	tMainDirection  = Mat::zeros(m,n,CV_64FC1);
//	int i,j,k;
//	double v1,v2;
//
//	for(i=1;i<m-1;i++) 
//	{
//		for(j=1;j<n-1;j++) 
//		{
//
//			v1 = abs( (tGArray[7].at<double>(i,j)-tGArray[3].at<double>(i,j)) - 
//				(tGArray[5].at<double>(i,j)-tGArray[1].at<double>(i,j)) );
//			v2 = abs( (tGArray[6].at<double>(i,j)-tGArray[2].at<double>(i,j)) - 
//				(tGArray[4].at<double>(i,j)-tGArray[0].at<double>(i,j)) );
//
//			if( v1 >= v2 )
//				tMainDirection.at<double>(i,j) = GEO_MAIN_HV;
//			else
//				tMainDirection.at<double>(i,j) = GEO_MAIN_DIAG;
//
//
//			for( k=0; k<4; k++ ) 
//			{
//				if( (tGArray[k].at<double>(i,j) > 0) && (tGArray[k+4].at<double>(i,j) < 0) )
//				{
//					DirectionLabelArray[k].at<double>(i,j) = GEO_MAX;
//				}
//				if( (tGArray[k].at<double>(i,j) < 0) && (tGArray[k+4].at<double>(i,j) > 0) )
//				{
//					DirectionLabelArray[k].at<double>(i,j) = GEO_MIN;
//				}
//				if( (tGArray[k].at<double>(i,j) > 0) && (tGArray[k+4].at<double>(i,j) > 0) )
//				{
//					DirectionLabelArray[k].at<double>(i,j) = GEO_ASCEND;
//				}
//				if( (tGArray[k].at<double>(i,j) < 0) && (tGArray[k+4].at<double>(i,j) < 0) )
//				{
//					DirectionLabelArray[k].at<double>(i,j) = GEO_DESCEND;
//				}
//				if( (tGArray[k].at<double>(i,j) == 0) && (tGArray[k+4].at<double>(i,j) == 0) )
//				{
//					DirectionLabelArray[k].at<double>(i,j) = GEO_EVEN;
//				}
//
//			}//end%for k=1:4
//
//		}//end%for j=2:n-1
//	}//	end%for i=2:m-1
//
//	tDirectionLabel0 = DirectionLabelArray[0];
//	tDirectionLabel1 = DirectionLabelArray[1];
//	tDirectionLabel2 = DirectionLabelArray[2];
//	tDirectionLabel3 = DirectionLabelArray[3];
//
//	return;
//}

//void GeoFeature(Mat &tDirectionLabel0,Mat &tDirectionLabel1,Mat &tDirectionLabel2,Mat &tDirectionLabel3
//	,Mat &tMainDirection,Mat &tImGeoLabel)
//{
//	Mat DirectionLabelArray[4];
//
//	DirectionLabelArray[0] = tDirectionLabel0;
//	DirectionLabelArray[1] = tDirectionLabel1;
//	DirectionLabelArray[2] = tDirectionLabel2;
//	DirectionLabelArray[3] = tDirectionLabel3;
//
//	int m = tDirectionLabel0.rows;
//	int n = tDirectionLabel0.cols;
//
//	tImGeoLabel = GEO_HILLSIDE * Mat::ones(m,n,CV_64FC1);
//
//	int i,j;
//	double d1,d2;
//
//	for( i=1; i<m-1; i++) 
//	{
//		for( j=1; j<n-1; j++) 
//		{
//			if (tMainDirection.at<double>(i,j) == 1)
//			{
//				d1 = DirectionLabelArray[1].at<double>(i,j);
//				d2 = DirectionLabelArray[3].at<double>(i,j);
//			}
//			else
//			{
//				d1 = DirectionLabelArray[0].at<double>(i,j);
//				d2 = DirectionLabelArray[2].at<double>(i,j);
//			}
//
//			if ( (d1==0) && (d2==0) )
//			{
//				tImGeoLabel.at<double>(i,j) = GEO_PEAK;
//			}
//
//			if ( (d1==1) && (d2==1) )
//			{
//				tImGeoLabel.at<double>(i,j) = GEO_PIT;
//			}
//
//			if ( ((d1==0) && (d2==1)) || ((d1==1) && (d2==0))  )
//			{
//				tImGeoLabel.at<double>(i,j) = GEO_SADDLE;
//			}
//
//			if ( ((d1==0) && (d2!=0)) || ((d1!=0) && (d2==0))  )
//			{
//				tImGeoLabel.at<double>(i,j) = GEO_RIDGE;
//			}
//
//			if ( ((d1==1) && (d2!=1)) || ((d1!=1) && (d2==1))  )
//			{
//				tImGeoLabel.at<double>(i,j) = GEO_RAVINE;
//			}
//
//			if ( ((d1!=0) && (d2!=0)) && ((d1!=1) && (d2!=1))  )
//			{
//				tImGeoLabel.at<double>(i,j) = GEO_HILLSIDE;
//			}
//
//		}//end%for j=2:m-1
//	}//end%for i=2:m-1
//
//	return;
//}
//bool Binarization(Mat &tImage,Mat tLabels, Mat &tGeo,Mat &tBwImage)
//{
//	double  *strens, *strensn, *labels, *labelsn,*Geo;
//	uchar *I;
//	int i,j,k,m;
//	int Nx[] = {-1, 1, 0, 0, -1, -1, 1,  1}; //8-neighbors
//	int Ny[] = {0, 0, -1, 1,  1, -1, 1, -1};
//	//0 peak, 1 pit, 2 saddle,3 ridge,4 ravine,5 hillside
//	//double WB[] = {1.5, 0.5, 0.9,1.2,  0.7, 1};
//	//double WF[] = {0.5, 1.5, 1.2, 0.7,  1.4,1};
//	double WB[] = {3.0, 0.3, 0.7,   2,  0.5, 1};
//	double WF[] = {0.3,   3, 1.5, 0.5,  0.7, 1};
//
//	int dimx,dimy,dimxy,colors;
//	double C,g;
//	int idxq, idxp;
//	double maxC = 441.673;
//	int converged;
//	int MAX_ITS = 1000; //uncomment below if you want to use this
//	int its = 0;
//
//	dimy = (int)tImage.rows;
//	dimx = (int)tImage.cols;
//	dimxy = dimx*dimy;
//	colors = 1;
//
//	Mat tLabelsn_m;
//	Mat tStrens_m(dimy,dimx,CV_64FC1,Scalar(0));
//	Mat tStrensn_m(dimy,dimx,CV_64FC1,Scalar(0));
//
//	tLabels.copyTo(tLabelsn_m);
//
//	Mat tImg8U;
//	tImage.convertTo(tImg8U,CV_8UC1);
//
//	I = tImg8U.data;
//
//	labels = (double *)tLabels.data;
//	labelsn = (double *)tLabelsn_m.data;
//	strens  = (double *)tStrens_m.data;
//	strensn = (double *)tStrensn_m.data;
//	Geo     = (double *)tGeo.data;
//
//	for(i=0;i<dimxy;i++) 
//	{
//		if(labels[i]!=0) 
//			strens[i] = 1;
//	}
//
//	double dbValp,dbValq;
//
//	converged = 0;
//	while(!converged){
//		its++;
//		converged = 1; //unless we make a change
//
//		for(i=0;i<dimxy;i++)
//		{
//			strensn[i] = strens[i];
//			labelsn[i] = labels[i];
//		}
//
//		for(i=1;i<dimx-1;i++)
//		{
//			for(j=1;j<dimy-1;j++)
//			{
//				idxp = j*dimx+i;
//
//				for(m=0;m<8;m++)
//				{
//					idxq = (j+Ny[m])*dimx + i+Nx[m];
//
//					if(labels[idxq] == 0) continue; 
//
//					dbValp = I[idxp ];
//					dbValq = I[idxq ];
//
//					C = sqrt((dbValp - dbValq)*(dbValp - dbValq)); 
//
//					if(labels[idxq] == 1)
//					{
//						C = C * WF[(int)Geo[idxp]];
//					}
//					if(labels[idxq] == -1)
//					{
//						C = C * WB[(int)Geo[idxp]];
//					}
//
//					g = 1-(C/maxC); //attack force
//
//					if(g*strens[idxq]>strensn[idxp]) //attack succeeds
//					{
//						strens[idxp] = g*strensn[idxq];
//						labelsn[idxp] = labels[idxq];
//						converged = 0; // keep iterating
//					}
//
//				}//for(m=0;m<8;m++)
//
//			}//for(j=1;j<dimy-1;j++)
//		}//for(i=1;i<dimx-1;i++)
//
//		//copy prev result
//		for(i=0;i<dimxy;i++) labels[i] = labelsn[i];;
//
//		//lets not go crazy...
//		if(its == MAX_ITS) break;
//	}
//
//	if(its == MAX_ITS)
//	{
//		return false;
//	}
//
//	//condition final result
//	for(i=0;i<dimxy;i++) if(labelsn[i]==-1) labelsn[i]=0;;
//
//	//tBwImage.create(dimy,dimx,CV_8UC1);
//	Mat tBw;
//	//tBw = ((tLabelsn_m + 1 )/2 )*255;
//	tBw = tLabelsn_m *255;
//	tBw.convertTo(tBwImage,CV_8UC1);
//
//	return true;
//}

//void ConnComponentByNiblack(Mat &tImage,Mat &tBw,int iASWF,double dbRatioTh,RECTS &tRects)
//{
//	/*DEBUG("");*/
//	stContourRects tContourRects;
//
//	bool bFill = true;
//	uchar cFillVal = 0;
//	Mat tFilledImg = tBw;
//
//	int iPixelTh = MAX(iASWF*iASWF,4);
//	iPixelTh = MIN(iASWF*iASWF,10);
//
//	ConnComponent(tBw,iPixelTh,tContourRects,bFill,cFillVal,tFilledImg);
//	//ConnComponent(tBwS,iPixelTh,tRectsS,contours,bFill,cFillVal,tFilledImg);
//	/*DEBUG("ConnCompinent Done");*/
//
//	stContourRects tMergedContourRects;
//	double dbOverlapTh = 0.1;
//
//	tContourRects.sort(CmpContourRectByXPosAscend);
//	MergeRectByOverlap(tContourRects,tMergedContourRects,dbOverlapTh);
//	/*DEBUG("MergeRectByOverlap");*/
//	tMergedContourRects.sort(CmpContourRectByXPosAscend);
//
//	tContourRects = tMergedContourRects;
//
//	double xs,ys,xe,ye;
//	int i,iNumBox;
//	double xs1,ys1,xe1,ye1,xsm,ysm,xem,yem;
//	double high1,width1,Ratio1,square1;
//	double high2,width2,Ratio2,square2;
//	double Uheight,Uwidth,Uratio;
//	double Oheight,Owidth,Osquare;
//	double dbDist;
//
//	int j;
//	int merged;
//
//	double dbMinLow = 100000,dbMaxHight = 0;
//
//	stContourRects::iterator pos,pos1;
//
//	stContourRects tNiblackContourRects;
//
//	vector<vector<Point>> tContoursF,tContoursB;
//
//	bool bMerged;
//	double dbCountOverlapTh = 0.9;
//	int iRet;
//
//	for( pos=tContourRects.begin(); pos!=tContourRects.end(); pos++ )
//	{
//
//		xs = pos->tRect.tTopLeft.x;
//		ys = pos->tRect.tTopLeft.y;
//		xe = pos->tRect.tButtomRight.x;
//		ye = pos->tRect.tButtomRight.y;   
//
//		if ( (ys < dbMinLow) &&(ys > 0)  )
//		{
//			dbMinLow = ys;
//		}
//		if ( ye > dbMaxHight  )
//		{
//			dbMaxHight = ye;
//		}
//
//		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
//		{
//			continue;
//		}
//
//		bMerged = false;
//
//		pos1 = pos;
//		pos1++;
//		for( ; pos1!=tContourRects.end(); pos1++ )  //实际上应该只和周围的box合并
//		{
//
//			xs = pos->tRect.tTopLeft.x;
//			ys = pos->tRect.tTopLeft.y;
//			xe = pos->tRect.tButtomRight.x;
//			ye = pos->tRect.tButtomRight.y;   
//
//			xs1 = pos1->tRect.tTopLeft.x;
//			ys1 = pos1->tRect.tTopLeft.y;
//			xe1 = pos1->tRect.tButtomRight.x;
//			ye1 = pos1->tRect.tButtomRight.y;         
//
//			if( (xs1 == 0) && (ys1 == 0) && (xe1 == 0) && (ye1 == 0) )
//			{
//				continue;
//			}
//
//			xsm = MIN(xs,xs1);
//			xem = MAX(xe,xe1);
//			ysm = MIN(ys,ys1);
//			yem = MAX(ye,ye1);   
//
//			high1   = ye-ys+1;
//			high2   = ye1-ys1+1;
//			width1  = xe-xs+1;
//			width2  = ye-ys+1;
//			square1 = high1*width1;
//			square2 = high2*width2;
//
//			dbDist = xs1-xe-1;
//
//			Uwidth = MAX(xe,xe1)-MIN(xs,xs1)+1;
//			Uheight = MAX(ye,ye1)-MIN(ys,ys1)+1;
//
//			Uratio = Uwidth / Uheight;
//
//
//			//if ( (Uratio < 1.25) && (dbDist <= 3) )
//			if ( (Uratio < dbRatioTh) && (dbDist <= 3) )
//			{
//				Mat tSubImage = tImage(Range((int)ysm,(int)yem+1),Range((int)xsm,(int)xem+1));
//				Mat tSubImageS;
//				GaussianBlur(tSubImage, tSubImageS, Size(3,3), 1.5, 1.5);
//
//				Mat tBwN(tSubImageS.size(),tSubImageS.type());
//				iRet = fyBinarization(tSubImageS,tBwN,BINARY_NIBLACK,9,9);
//				tBwN = 255-tBwN;
//				if ( iRet < 0 )
//				{
//					return;
//				}
//
//				int iSubHight,iSubWidth;
//				iSubHight = tSubImage.rows;
//				iSubWidth = tSubImage.cols;
//
//				Mat tMask = Mat::zeros(tSubImage.size(),tSubImage.type());
//				tMask(Range(1,iSubHight-1),Range(1,iSubWidth-1)) = 255*Mat::ones(iSubHight-2,iSubWidth-2,tImage.type());
//
//				Mat tBwN1;
//				bitwise_and(tBwN,tMask,tBwN1);
//				tBwN = tBwN1;
//
//				dilate(tBwN,tBwN1,Mat::ones(3,3,tImage.type()));
//				erode(tBwN1,tBwN,Mat::ones(3,3,tImage.type()));
//
//				/*				ShowMat(tBwN,"tBwN");*/
//
//				bFill = false;
//				ConnComponent(tBwN,iPixelTh,tNiblackContourRects,bFill,cFillVal,tFilledImg);
//
//				tContoursF.clear();
//				tContoursB.clear();
//
//				list<vector<Point>>::iterator posContours;
//				vector<Point>::iterator posPoint;
//				for ( posContours=pos->tContours.begin(); posContours!=pos->tContours.end(); posContours++ )
//				{
//					for ( posPoint=posContours->begin(); posPoint!=posContours->end(); posPoint++ )
//					{
//						posPoint->x = posPoint->x-(int)xsm;
//						posPoint->y = posPoint->y-(int)ysm;
//					}
//
//					tContoursF.push_back(*posContours);
//				}
//				for ( posContours=pos1->tContours.begin(); posContours!=pos1->tContours.end(); posContours++ )
//				{
//					for ( posPoint=posContours->begin(); posPoint!=posContours->end(); posPoint++ )
//					{
//						posPoint->x = posPoint->x-(int)xsm;
//						posPoint->y = posPoint->y-(int)ysm;
//					}
//
//					tContoursF.push_back(*posContours);
//				}
//
//				stContourRects::iterator posContourRects;
//
//				for ( posContourRects=tNiblackContourRects.begin(); posContourRects!=tNiblackContourRects.end(); posContourRects++ )
//				{
//					for ( posContours=posContourRects->tContours.begin(); posContours!=posContourRects->tContours.end(); posContours++ )
//					{
//						tContoursB.push_back(*posContours);
//					}
//				}
//
//				bMerged = false;
//				bMerged = IsConnContour(tSubImage,tContoursF,tContoursB,dbCountOverlapTh);
//				if( bMerged )
//				{
//
//					pos->tRect.tTopLeft.x     = xsm;
//					pos->tRect.tTopLeft.y     = ysm;
//					pos->tRect.tButtomRight.x = xem;
//					pos->tRect.tButtomRight.y = yem;   
//
//					pos1->tRect.tTopLeft.x     = 0;
//					pos1->tRect.tTopLeft.y     = 0;
//					pos1->tRect.tButtomRight.x = 0;
//					pos1->tRect.tButtomRight.y = 0;   
//
//				}//if( bMerged )
//
//
//			}//if ( Uratio < 1.25)
//
//
//		}//end% for j=i+1:numbox
//	}//end % for i=1:numbox
//
//	tRects.clear();
//	/*DEBUG("");*/
//
//	SHAPE_RECT tRect;
//	for( pos=tContourRects.begin(); pos!=tContourRects.end(); pos++ )
//	{
//
//		xs = pos->tRect.tTopLeft.x;
//		ys = pos->tRect.tTopLeft.y;
//		xe = pos->tRect.tButtomRight.x;
//		ye = pos->tRect.tButtomRight.y;   
//
//		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
//		{
//			continue;
//		}
//
//
//		tRect.tTopLeft.x     = xs;
//		tRect.tTopLeft.y     = ys;
//		tRect.tButtomRight.x = xe;
//		tRect.tButtomRight.y = ye;
//		tRects.push_back(tRect);
//
//	}//for( i=0; i<iNumBox; i++ )
//	/*DEBUG("");*/
//	return;
//
//}

bool CmpContourRectByXPosAscend( const stRectContour &tRect1, const stRectContour &tRect2 )
{
	return (tRect1.tRect.tTopLeft.x < tRect2.tRect.tTopLeft.x);
}

int PixelCount(Mat &tBw,int cVal)
{
	/*DEBUG("");*/
	// 	int bins = 257;
	// 	int histSize[] = {bins};
	// 	float granges[] = { 0, 255 };
	// 	const float* ranges[] = { granges};
	// 	int channels[] = {0};
	// 	MatND hist;
	// 
	// 	calcHist(&tBw, 1, channels, Mat(),hist, 1, histSize, ranges,true,false );
	// 
	// 	vector<float> tHist;
	// 
	// 	for( int k=0; k<hist.rows; k++)
	// 	{
	// 		tHist.push_back(hist.at<float>(k,0));
	// 	}

	int iSum=0;
	int iVal;

	for ( int i=0; i<tBw.rows; i++ )
	{
		for ( int j=0; j<tBw.cols; j++ )
		{
			iVal = tBw.at<uchar>(i,j);

			if( iVal == cVal )
			{
				iSum++;
			}
		}

	}

	/*DEBUG("");*/
	return iSum;
}

bool IsConnContour(const Mat &tBw,const vector<vector<Point>> &tContoursF,const vector<vector<Point>> &tContoursB,double dbOverlapTh)
{
	/*DEBUG("");*/
	Mat tBwF = Mat::zeros(tBw.size(),tBw.type());

	int cVal = 255;

	drawContours(tBwF,tContoursF,-1,Scalar(255),CV_FILLED);
	/*DEBUG("");*/

	int iBwFCount = PixelCount(tBwF,cVal);

	/*	ShowMat(tBwF,"tBwF");*/

	vector<vector<Point>>::const_iterator pos;

	vector<vector<Point>> tTmpContoursB;
	Mat tBwB,tBwC;
	int iBwCCount;
	double dbRate;

	for ( pos=tContoursB.begin();pos!=tContoursB.end(); pos++ )
	{
		tTmpContoursB.clear();

		tTmpContoursB.push_back(*pos);
		tBwB = Mat::zeros(tBw.size(),tBw.type());

		drawContours(tBwB,tTmpContoursB,-1,Scalar(255),CV_FILLED);

		/*		ShowMat(tBwB,"tBwB");*/

		bitwise_and(tBwF,tBwB,tBwC);

		/*		ShowMat(tBwC,"tBwC");*/

		iBwCCount = PixelCount(tBwC,cVal);

		dbRate = double(iBwCCount) / double(iBwFCount);

		if ( dbRate > dbOverlapTh )
		{
			/*DEBUG("True");*/
			return true;
		}

	}//for ( pos=tContoursB.begin();pos=tContoursB.end(); pos++ )

	/*DEBUG("False");*/
	return false;

}

void ConnComponent(Mat &tBw,int iPixelTh,stContourRects &tContourRects,bool bFill,uchar cFillVal,Mat &tFilledImg)
{
	/*DEBUG("");*/
	vector<vector<Point>> contours;
	vector<Vec4i> hierarchy;

	Mat tBwImageTmp;
	tBw.copyTo(tBwImageTmp);


	findContours(tBwImageTmp, contours , hierarchy , CV_RETR_TREE , CV_CHAIN_APPROX_NONE,Point(0, 0)); //查找连通区域


	double dbArea = 0;
	SHAPE_RECT tRect;

	stRectContour tRectContour;

	int iNum = 0;

	tContourRects.clear();

	if (!contours.empty())
	{
		for (int idx=0;idx>=0;idx=hierarchy[idx][0])
			//for (int idx=0;idx<contours.size();idx++)
		{
			Rect cBoundingBox = boundingRect(Mat(contours[idx]));

			Mat tRectImg = tBw(Range(cBoundingBox.y,cBoundingBox.y + cBoundingBox.height), 
				Range(cBoundingBox.x,cBoundingBox.x + cBoundingBox.width));

			//ShowMat(tRectImg);

			dbArea = contourArea(contours[idx]);

			if ( dbArea < iPixelTh )
			{
				if ( bFill )
				{
					Point pt;
					for ( int i=0; i<contours[idx].size(); i++ )
					{
						pt = contours[idx][i];
						tFilledImg.at<uchar>(pt.y,pt.x) = cFillVal;
					}

				}//if ( bFill )

				continue;
			}

			/*			ShowMat(tRectImg,"conn",true);*/

			tRectContour.tRect.tTopLeft.x = cBoundingBox.x;
			tRectContour.tRect.tTopLeft.y = cBoundingBox.y;
			tRectContour.tRect.tButtomRight.x = tRectContour.tRect.tTopLeft.x + cBoundingBox.width-1;
			tRectContour.tRect.tButtomRight.y = tRectContour.tRect.tTopLeft.y + cBoundingBox.height-1;

			tRectContour.tContours.clear();
			tRectContour.tContours.push_back(contours[idx]);

			tContourRects.push_back(tRectContour);

			//iNum++;
			//sprintf(ch,"%d",iNum);
			//string str = "Connection";
			//str = str + ch;
			//ShowMat(tRectImg,str);

		}//for (int idx=0;idx>=0;idx=hierarchy[idx][0])
	}//if (!contours.empty())

	/*DEBUG("");*/
	return;
}

void MergeRectByOverlap(const stContourRects &tContourRects,stContourRects &tMergedContourRects,double dbOverlapTh)
{
	/*DEBUG("");*/
	stContourRects tContourRectsTmp;
	tContourRectsTmp = tContourRects;

	double xs,ys,xe,ye;
	int i,iNumBox;

	double xs1,ys1,xe1,ye1,xsm,ysm,xem,yem;
	double height1,width1,Ratio1,square1;
	double height2,width2,Ratio2,square2;
	double Uheight,Uwidth,Uratio;
	double Oheight,Owidth,Osquare;

	bool bVerticalOverlaped;
	bool bAreaOverlaped;
	bool bTooDiv;

	int j;
	int merged;

	double dbMinLow = 100000,dbMaxHight = 0;

	stContourRects::iterator pos,pos1;

	for( pos=tContourRectsTmp.begin(); pos!=tContourRectsTmp.end(); pos++ )
	{

		xs = pos->tRect.tTopLeft.x;
		ys = pos->tRect.tTopLeft.y;
		xe = pos->tRect.tButtomRight.x;
		ye = pos->tRect.tButtomRight.y;   

		if ( (ys < dbMinLow) &&(ys > 0)  )
		{
			dbMinLow = ys;
		}
		if ( ye > dbMaxHight  )
		{
			dbMaxHight = ye;
		}

		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
		{
			continue;
		}

		pos1=pos;
		pos1++;
		for( ; pos1!=tContourRectsTmp.end(); pos1++ )  //实际上应该只和周围的box合并
		{

			xs = pos->tRect.tTopLeft.x;
			ys = pos->tRect.tTopLeft.y;
			xe = pos->tRect.tButtomRight.x;
			ye = pos->tRect.tButtomRight.y;   

			xs1 = pos1->tRect.tTopLeft.x;
			ys1 = pos1->tRect.tTopLeft.y;
			xe1 = pos1->tRect.tButtomRight.x;
			ye1 = pos1->tRect.tButtomRight.y;         

			if( (xs1 == 0) && (ys1 == 0) && (xe1 == 0) && (ye1 == 0) )
			{
				continue;
			}

			xsm = MIN(xs,xs1);
			xem = MAX(xe,xe1);
			ysm = MIN(ys,ys1);
			yem = MAX(ye,ye1);   

			height1 = ye-ys+1;
			width1 = xe-xs+1;
			Ratio1 = width1 / height1;
			square1 = width1*height1;

			height2 = ye1-ys1+1;
			width2 = xe1-xs1+1;
			Ratio2 = width2 / height2;
			square2 = width2*height2;

			Uwidth = MAX(xe,xe1)-MIN(xs,xs1)+1;
			Uheight = MAX(ye,ye1)-MIN(ys,ys1)+1;

			Uratio = Uwidth / Uheight;

			Owidth = width1 + width2 - Uwidth ;
			Oheight = height1 + height2 - Uheight;

			Osquare = Owidth * Oheight;

			merged = 0;

			bAreaOverlaped    = ((Owidth > 0)&&(Oheight > 0));

			if ( (bAreaOverlaped) && 
				((Osquare / MIN(square1,square2)) > dbOverlapTh) &&
				( abs(height1-height2) < 5*MIN(height1,height2)) &&
				( abs(width1-width2) < 5*MIN(width1,width2))
				) 
			{
				merged = 1;

			}// if (  bAreaOverlaped  ) 

			if( 1 == merged )
			{

				pos->tRect.tTopLeft.x     = xsm;
				pos->tRect.tTopLeft.y     = ysm;
				pos->tRect.tButtomRight.x = xem;
				pos->tRect.tButtomRight.y = yem;   

				pos1->tRect.tTopLeft.x     = 0;
				pos1->tRect.tTopLeft.y     = 0;
				pos1->tRect.tButtomRight.x = 0;
				pos1->tRect.tButtomRight.y = 0;   

			}//if( 1 == merged )

		}//end% for j=i+1:numbox
	}//end % for i=1:numbox

	tMergedContourRects.clear();

	stRectContour tRectContour;
	for( pos=tContourRectsTmp.begin(); pos!=tContourRectsTmp.end(); pos++ )
	{

		xs = pos->tRect.tTopLeft.x;
		ys = pos->tRect.tTopLeft.y;
		xe = pos->tRect.tButtomRight.x;
		ye = pos->tRect.tButtomRight.y;   

		if( (xs == 0) && (ys == 0) && (xe == 0) && (ye == 0) )
		{
			continue;
		}


		tRectContour.tRect.tTopLeft.x     = xs;
		tRectContour.tRect.tTopLeft.y     = ys;
		tRectContour.tRect.tButtomRight.x = xe;
		tRectContour.tRect.tButtomRight.y = ye;

		tMergedContourRects.push_back(*pos);

	}//for( i=0; i<iNumBox; i++ )

	/*DEBUG("Done");*/
	return;

}


}